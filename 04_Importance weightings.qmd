# Weightings

Weightings define the importance of different indicators, or the amount each contributes towards a condition score, relative to other indicators (more information [here](01_general%20approach.qmd)).

> **Example:** If deadwood was considered twice as important as horizontal complexity, these indicators might have weightings of 100 and 50, respectively (on a scale of 0 - 100).

## Results summary

There a lot of variation between respondents for [raw indicator weightings](#sec-raw_weights), much more than there was between actual indicators. This may have be partly because respondents varied a lot in terms of the [amount of difference between indicators](#variation%20in%20raw%20indicators). This limited what useful information could be drawn from raw weightings, and prompted an exploration of the [ranking of indicator weightings](#sec-rank_weights) by respondents and [Standardised weights](#sec-standardised_weights) (transformed so that all respondents varied the same amount between indicators).

Many respondents provided estimates that were very similar between indicators. The implications of this are discussed [below](#variation%20in%20raw%20indicators).

There were clear [patterns](#sec-patterns) of disagreement between respondents in round 1, that might be used to inform the second round of deliberation.

## Recommendations for next workshop

> Q: How how do we best to elicit useful and robust weighting estimates from the expert panel?

The next workshop should first determine a consensus as to whether or not differential indicator weightings are appropriate in principle, and (assuming they are) then approximately how big the range between the most and least important indicators should be. e.g. through series of quick votes on a virtual poll:

> Think to yourself: "My most important indicator is \_\_\_\_ and my least is \_\_\_", and select an answer from the following:
>
> -   Both are of equal importance
>
> -   There is only a small difference
>
> -   My least important is 1/2 as important as the most important
>
> -   My least important is 1/3 as important as the most important

etc., up until 1/10.

This report should be shared with all respondents. Our approach should be transparent and accessible to the respondents, in particular to give a working understanding of [how condition scores will be estimated from indicator measurements](01_general%20approach.qmd) to promote effective discussion and deliberation in forthcoming workshops.

Some consideration should be given to alternative or adapted methods to estimate indicator weights. Options include:

-   Relying more on the rank order of estimates, rather than the raw weighting, and building consensus based on that (initial exploration [below](#sec-rank_weights)).

    -   Reliable information on the order of indicators could be used to guide the assignment of weightings (ideally by some formalised process).

    -   Future workshop sessions for weighting estimates could be orientated more around sorting and grouping indicators by their importance. This could incorporate small-group sessions, or a methodology like the [Q-Method](#0).

-   Allocating a limited number of "points" between indicators

The [patterns and groupings](#sec-patterns) between respondents could be used to construct workshop breakout groups. For example, groups could be designed to bring together respondents who differed most in their initial responses.

```{r load curated data, echo = F, include = F, eval = T }
extraction.location <- "Data\\Delphi round 1\\"
load(paste0(extraction.location,"curated.RData"))
```

```{r libraries_data, echo = F, include = F, eval = T }

# LIBARIES ---------------------------------------------------------------
# library(readxl)
library(tidyverse)
library(ggpubr)
library(plotly)
library(htmltools)

# library(stringr)
# library(plotly)
# library(htmlwidgets)
# library(gridExtra)
# library(grid)
library(DT)
# library(ggiraph)
# library(cowplot)
# library(ggnewscale)
# library(Polychrome)
source("Scripts\\functions_delphi_analysis.R")

forms.direct <- "Data\\Delphi round 1\\response sheets\\"
extraction.location <- "Data\\Delphi round 1\\"

# add reverce rank of wieghts by each respondant to just.one.df
just.one.df <- just.one.df %>% 
  group_by(respondant_name) %>% 
  mutate(rank_weight = rank(-weight, ties.method = "min")) %>% 
  ungroup()

```

## Respondents varied in the amount of difference between indicators {#variation in raw indicators}

Respondents varied in terms of [the amount of difference]{.underline} between their raw indicator weights. The figure below shows how much variation there typically was between weightings for each respondent. Respondents with lower standard deviations weighted indicators more similarly, while those with higher tended to vary much more between indicators.

```{r raw weights sd, echo = F , results="asis", fig.width = 6, fig.height=2, out.height= "30%", caption = "Variation in indicator weights by respondants: respondants with higher standard devidation in their answers varied more between indicators."}
# plotly boxplot of the variation in weights given by each respondant

# calculate the standard deviation of the weights given by each respondant
respondant.sd <- just.one.df %>%
  dplyr::select(respondant_name, weight) %>%
  group_by(respondant_name) %>%
  summarise(sd = sd(weight)) %>%
  arrange(desc(sd))

# ggplot horizontal boxplot of the standard deviation of the weights given by each respondant
respondant.sd.plot <- ggplot(respondant.sd, aes(y = sd, x = 0)) +
  geom_boxplot(width = 0.5, color="grey60", fill = NA,
               outlier.shape = NA) +
  geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                         size = 3, shape = 16,
                         aes(color = respondant_name,
                             tooltip = respondant_name,
                             data_id = respondant_name
                             )
                         ) +
  labs(y = "Standard deviation of weights", x = NULL, title = "Variation by respondent" ) +
  scale_x_continuous(limits = c(-0.3,0.3)) +
  scale_y_continuous(limits = c(0,NA)) +
  scale_colour_manual(values = respondant_colours, name = "Respondant") +
  theme_pubr()+
  theme(plot.title = element_text(size = 12),
        plot.subtitle = element_text(size = 12),
        legend.title = element_text(size = 12 , face = "bold"),
        legend.text =  element_text(size = 9),
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = 12),
        axis.title =  element_text(size = 12),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "right",
        plot.margin = margin(0.5, 1, 0.5, 1, "cm")
  ) +
  coord_flip() 

    girafe(
    ggobj = respondant.sd.plot,
    width_svg = 12,
    height_svg = 4,
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 
    

    
    
```

### Implications of low weighting variation between-indicators {#sec-vary-implicartions}

A lot of respondents provided weights which did not vary to a large degree between indicators. Most respondents, tended not to vary by more than `r median(respondant.sd$sd)` from their average weight. This small variation may be due to a tendency for respondents to consider that "all indicators are important". However, using weights with a small amount of variation will not have a large impact on their relative contribution to the final ecological condition score: essentially all indicators will be treated as being approximately equal in value. While there is nothing technically wrong with this, there is a risk that equal weightings are adopted inadvertently, without full consideration of the potential consequences.

> Question for respondents: Do you think being more variable in the weights you gave might be appropriate?

### 

## Exploration of weightings

The figures below show the weightiness for each indicator given by respondents: the raw estimates as provided, the rank of those estimates by respondent, and then standardised estimates (transformed so that all respondent's answers varied the same amount)

::: panel-tabset
### Raw weights {#sec-raw_weights}

Raw weightings varied a lot between respondents for each indicator, much more than the variation between the indicators themselves (in terms of their average). This limits how useful the first round of estimated raw weightings will be to differentiate between different indicators importance.

```{r raw weights ggiraph, fig.height= 1,echo = F , results="asis", caption = "Expert opnion indicator weights: estimates for all indicators for all respontants, with boxplots showing the median and inter-quartile range for each indicator."}
#| column: screen-inset-shaded

#add a col to just.one.df that is the proportion of all of each respondents weight given to each indicator, and one of weights standardised by respondant
just.one.df <- just.one.df %>%
  group_by(respondant_name) %>%
  mutate(weight_share = weight/sum(weight, na.rm = T) * 100,
         weight_standardised = (weight - mean(weight, na.rm = T))/sd(weight, na.rm = T)         ) %>%
  ungroup()

  # Order the levels of sheet_name by the median of rank_weight
ordered_levels <- just.one.df %>%
  group_by(sheet_name) %>%
  summarise(av_weight = median(weight, na.rm = TRUE)) %>%
  arrange(-av_weight) %>%
  pull(sheet_name)

  
# just some background lines to help read the graph
  indicator.lines = data.frame(
    y = rep(c(0,100), each = length(just.one.df$sheet_name %>% unique())),
    sheet_name = rep(just.one.df$sheet_name %>% unique(), times = 2) %>% 
      as.factor()
  ) %>% 
    mutate(sheet_name = factor(sheet_name, levels = ordered_levels))
    
    

  indiv.weights <- ggplot(data = just.one.df %>% 
                            mutate(sheet_name = factor(just.one.df$sheet_name, levels = ordered_levels))) +
    geom_line(data = indicator.lines, color = "grey95",
              aes(x = sheet_name, y = y,
                  data_id = sheet_name),
              show.legend = FALSE) +
    geom_boxplot(aes(x = sheet_name, y = weight), 
               width=0.5, color="grey30", fill = "white", alpha=0.2,
               outlier.shape = NA) +
    geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                           size = 2, shape = 16,
                           aes(x = sheet_name, y = weight,
                               col = respondant_name,
                               alpha = cert_weight,
                               tooltip = paste0(respondant_name, "<br>",sheet_name, "<br>Weight = ", weight, "<br>Certainty = ", cert_weight),
                               data_id = respondant_name #,
                               # text = map(
                               #   paste0("<b>", respondant_name, "</b><br>",
                               #          "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                               # HTML)
                           )) +
    scale_colour_manual(values = respondant_colours, name = "Respondant") +
    scale_y_continuous(limits = c(0,100)) +
    guides(color = F#guide_legend(ncol =1)
           , alpha = F) +
    labs(y = NULL, x = NULL, title = "Indicators weightings") +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 9),
          axis.text.x = element_text(angle = -60, hjust = 0, size = 10),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.box = "vertical",  # Set the legend box to vertical
          legend.position = "right",
          plot.margin = margin(0.2, 0.2, 0.2, 0.2, "cm")
    ) 
  
    girafe(
    ggobj = indiv.weights,
    width_svg = 10,
    height_svg = 6, 
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 

```

### Ranked weights {#sec-rank_weights}

The rank of weightings from each respondent provide some useful information, particularly on which indicators are consistently considered to be most and least important

```{r ranked weights ggiraph, echo = F , results="asis", caption = "Expert opnion indicator weights: ranks of indicator importance weightings for all respontants, with boxplots showing the median and inter-quartile range for each indicator's rank."}
#| column: screen-inset-shaded
  # Order the levels of sheet_name by the median of rank_weight
ordered_levels <- just.one.df %>%
  group_by(sheet_name) %>%
  summarise(median_rank = median(rank_weight, na.rm = TRUE)) %>%
  arrange(median_rank) %>%
  pull(sheet_name)

# Apply the ordered levels to the sheet_name variable
# just.one.df$sheet_name <- factor(just.one.df$sheet_name, levels = ordered_levels)


  indiv.weights <- ggplot(data = just.one.df %>% 
                            mutate(sheet_name = factor(just.one.df$sheet_name, levels = ordered_levels))) +
    geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                           size = 2, shape = 16,
                           aes(x = sheet_name, y = rank_weight,
                               col = respondant_name,
                               alpha = cert_weight,
                               tooltip = paste0(respondant_name, "<br>",sheet_name, "<br>Weight = ", weight, "<br>Weight rank = ", rank_weight, "<br>Certainty = ", cert_weight),
                               data_id = respondant_name #,
                               # text = map(
                               #   paste0("<b>", respondant_name, "</b><br>",
                               #          "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                               # HTML)
                           )) +
    geom_boxplot(aes(x = sheet_name, y = rank_weight), 
             width=0.5, color="grey30", fill = NA,
               outlier.shape = NA) +
    scale_colour_manual(values = respondant_colours, name = "Respondant") +
    scale_y_continuous(limits = c(1,14)) + 
    scale_y_reverse() +
    guides(color = F#guide_legend(ncol =1)
           , alpha = F) +
    labs(y = NULL, x = NULL, title = "Indicators weighting ranks") +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 9),
          axis.text.x = element_text(angle = -60, hjust = 0, size = 10),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.box = "vertical",  # Set the legend box to vertical
          legend.position = "right",
          plot.margin = margin(0.2, 0.2, 0.2, 0.2, "cm")
    ) 
  
    girafe(
    ggobj = indiv.weights,
    width_svg = 10,
    height_svg = 6, 
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 

```

### Standardised weights {#sec-standardised_weights}

Standardised weights were calculated so that all respondents varied the same amount, around the same average (0). This is useful for comparing the relative importance of indicators across respondents, while ignoring the difference between respondents in terms of how much their weightings varied. However, those differences may be important, and should not be ignored completely. There may be good reasons why some respondents though weightings should vary more than others.

```{r standardised weights ggiraph, echo = F , results="asis", caption = "Standardised weights: weights given to each indicator by respondents, standardised so that all respondents varied the same amount, with boxplots showing the median and inter-quartile range for each indicator's weight."}
#| column: screen-inset-shaded
  # Order the levels of sheet_name by the median of rank_weight
ordered_levels <- just.one.df %>%
  group_by(sheet_name) %>%
  summarise(median_standard_weight = median(weight_standardised, na.rm = TRUE)) %>%
  arrange(-median_standard_weight) %>%
  pull(sheet_name)

# Apply the ordered levels to the sheet_name variable
# just.one.df$sheet_name <- factor(just.one.df$sheet_name, levels = ordered_levels)

 indiv.weights <- ggplot(data = just.one.df %>% 
                            mutate(sheet_name = factor(just.one.df$sheet_name, levels = ordered_levels))) +
    geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                           size = 2, shape = 16,
                           aes(x = sheet_name, y = weight_standardised,
                               col = respondant_name,
                               alpha = cert_weight,
                               tooltip = paste0(respondant_name, "<br>",sheet_name, "<br>Weight = ", weight, "<br>Weight rank = ", rank_weight, "<br> Standardised weight = ", weight_standardised, "<br>Certainty = ", cert_weight),
                               data_id = respondant_name #,
                               # text = map(
                               #   paste0("<b>", respondant_name, "</b><br>",
                               #          "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                               # HTML)
                           )) +
    geom_boxplot(aes(x = sheet_name, y = weight_standardised), 
             width=0.5, color="grey30", fill = NA,
               outlier.shape = NA) +
    scale_colour_manual(values = respondant_colours, name = "Respondant") +
    # scale_y_continuous(limits = c(1,14)) + 
    guides(color = F#guide_legend(ncol =1)
           , alpha = F) +
    labs(y = NULL, x = NULL, title = "Standardised weightings by respondant") +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 9),
          axis.text.x = element_text(angle = -60, hjust = 0, size = 10),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.box = "vertical",  # Set the legend box to vertical
          legend.position = "right",
          plot.margin = margin(0.2, 0.2, 0.2, 0.2, "cm")
    ) 
  
    girafe(
    ggobj = indiv.weights,
    width_svg = 10,
    height_svg = 6, 
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 
    

```

### Indicator weightings data summary

```{r caption = "*the average prortion of each respondants' sum weights given to each indicator."}
#| column: screen-inset-shaded



column_names <- c("Indicator", "Average weight", "Average weight rank (lower better)", "Average standardised weight","Ranked most important \n(% responants)", "Ranked least important (% responants)"
                  #, "Sum of Ranks (lower better)"
                  )

DT::datatable(just.one.df %>%
                group_by(sheet_name) %>%
                summarise(
                  av_weight = round(mean(weight, na.rm = T), 0),
                  av_rank_weight = round(mean(rank_weight, na.rm = T), 0),
                  ave_weight_standardised = round(mean(weight_standardised, na.rm = T), 2),
                  n_rank_1 = round(sum(rank_weight == 1)/ n() * 100),
                  n_lowest = round(sum(rank_weight == max(rank_weight, na.rm = T))/ n() * 100)# but rank is ordered, so actually this is the "min"
#,
                  # sum_rank_weight = sum(rank_weight, na.rm = T),
                  ) %>%
                arrange(-av_weight) %>%
                mutate(sheet_name = paste0("<b>", sheet_name, "</b>")),
              rownames = F,
              escape = F,
              colnames = column_names,  # Specify column names
              options = list(
                dom = 't',
                paging = F,
                ordering = T,
                searching = F,
                info = F,
                columnDefs = list(list(width = '100px', targets = "_all"))
)) 


```
:::

### Conclusions from round 1 weightings estimates

There was too much variation in raw weightings between respondents to draw many useful conclusions from that data directly.

The rankings of indicators by their weighting, and standardised weightings (by respondent) also exhibited a lot of variation, but there were a few general trends worth noting (to which there are many exceptions):

-   Deadwood, regeneration and horizontal complexity were generally ranked highest
-   Tree health and woodland extent generally ranked low, and the lowest by many respondents
    -   Anthropogenic damage also typically scored low importance

## Patterns between respondents {#sec-patterns}

The plots below attempt to group respondents by the weightings they gave for different indicators. This may help respondents identify where their own responses may be based on experiences that are less relevant to more "typical" woodland. In the later case, they may wish to alter their weightings and provide further input via a comment/exception to their general estimation.

### Principle Component analysis

-   **Clustering** of respondents reflects general agreement/disagreement in indicator weightings.

-   **Arrow directions** suggest which indicators generally drive disagreements between different locations on the plot.

-   Longer arrows with a **warmer colour** suggest indicators that might contribute more to disagreements.

-   The **center point** attempts to locate the "average respondent", as best it can (i.e on a 2 dimensional screen).

Participants might want to reflect on those respondents with whom they generally agree/disagree, and what might drive disagreements most.

```{r PCA function}
library(factoextra)
library(FactoMineR)
library(dplyr)
library(tidyr)
library(ggrepel)

generate_interactive_PCA <- function(data, weight_variable) {
  # Select relevant columns and spread the data  
  weights.mat <- data %>%
    dplyr::select(respondant_name, sheet_name, !!sym(weight_variable)) %>%
    spread(sheet_name, !!sym(weight_variable)) %>%
    # Make respondant_name the row names     
    column_to_rownames(var = "respondant_name") %>%
    na.omit() %>% # Filter out rows with all NA     
    as.matrix()  
  
  # Generate PCA   
  pca <- PCA(weights.mat, graph = F)  
  
  # Create PCA biplot
  biplot <- fviz_pca_biplot(pca, repel = TRUE,
                            col.var = "contrib", # Color by contributions to the PC
                            gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                            col.ind = "#696969",  # Individuals color
                            geom.ind = "point",
                            col.quanti.sup = "black",
                            col.ind.sup = "black",
                            col.var.sup = "black",
                            pointsize = 1,
                            title = "",
                            axes = c(1, 2),
                            ellipse.level = 0.95,
                            labelsize = 3,
                            legend.title = "",
                            legend.position = "none",
                            legend.justification = "none",
                            legend.direction = "none",
                            legend.box = "none",
                            repel.max.iter = 1000,
                            repel.strength = 5,
                            repel.seed = 123,
                            ggtheme = theme_pubr())
  
  # Add labels using ggrepel
  biplot + geom_text_repel(data = as.data.frame(pca$ind$coord),
                           aes(x = Dim.1, y = Dim.2, label = row.names(pca$ind$coord)),
                           box.padding = 0.5,
                           point.padding = 0.5,
                           segment.color = "grey",
                           segment.size = 0.5,
                           segment.alpha = 0.5,
                           size = 3,
                           force = 2
  )
}





```

::: panel-tabset
#### Standardised weightings {#sec-patterns_standardised}

```{r PCA standardised weights, echo = F, results="asis"}
#| column: screen-inset-shaded

generate_interactive_PCA(just.one.df, "weight_standardised")
```

#### Raw weightings

```{r PCA weights raw, echo = F, results="asis"}
#| column: screen-inset-shaded

generate_interactive_PCA(just.one.df, "weight")
```

#### Ranked weightings

```{r PCA rank weights, echo = F, results="asis"}
#| column: screen-inset-shaded

generate_interactive_PCA(just.one.df, "rank_weight")
```
:::

### Conclusions - patterns between respondents
