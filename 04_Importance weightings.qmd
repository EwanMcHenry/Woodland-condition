# Weightings

Weightings define the importance of different indicators, or the amount each contributes towards a condition score, relative to other indicators.

> **Example:** If deadwood was considered twice as important as horizontal complexity, these indicators might have weightings of 100 and 50, respectively (on a scale of 0 - 100).

## Results summary

There was much more variation between respondents than there was between indicators. This may have be partly because respondents differed a lot in terms of the absolute difference between indicators of higher or lower importance. With that in mind, it may be more useful to explore the indicator ranks by respondents, or the proportion of their total weightings given to each indicator.

Many respondents provided estimates that were very similar between indicators. The implications of this are discussed below.

## Recommendations

> Q: How how do we best to elicit useful and robust weighting estimates from the expert panel?

The next workshop should first determine a consensus as to whether or not differential indicator weightings are appropriate in principle, and (assuming they are) then approximately how big the range between the most and least important indicators should be. e.g. through series of quick votes on a virtual poll:

> Think to yourself: "My most important indicator is \_\_\_\_ and my least is \_\_\_", and select an answer from the following:
>
> -   Both are of equal importance
>
> -   There is only a small difference
>
> -   My least important is 1/2 as important as the most important
>
> -   My least important is 1/3 as important as the most important

etc., up until 1/10.

This report should be shared with all respondents. Our approach should be transparent and accessible to the respondents, in particular to give a working understanding of [how condition scores will be estimated from indicator measurements](01_general%20approach.qmd) to promote effective discussion and deliberation in forthcoming workshops.

Some consideration should be given to alternative or adapted methods to estimate indicator weights. Options include

-   Relying more on the rank order of estimates, rather than the raw weighting, and building consensus based on that (initial exploration below).

    -   Reliable information on the order of indicators could be used to guide the assignment of weightings (ideally by some formalised process).

    -   Future workshop sessions for weighting estimates could be orientated more around sorting and grouping indicators by their importance. This could incorporate small-group sessions, or a methodology like the [Q-Method](#0).

-   Allocating a limited number of "points" between indicators

```{r load curated data, echo = F, include = F, eval = T }
extraction.location <- "Data\\Delphi round 1\\"
load(paste0(extraction.location,"curated.RData"))
```

```{r libraries_data, echo = F, include = F, eval = T }

# LIBARIES ---------------------------------------------------------------
# library(readxl)
library(tidyverse)
library(ggpubr)
library(plotly)
library(htmltools)

# library(stringr)
# library(plotly)
# library(htmlwidgets)
# library(gridExtra)
# library(grid)
library(DT)
# library(ggiraph)
# library(cowplot)
# library(ggnewscale)
# library(Polychrome)
source("Scripts\\functions_delphi_analysis.R")

forms.direct <- "Data\\Delphi round 1\\response sheets\\"
extraction.location <- "Data\\Delphi round 1\\"

# add reverce rank of wieghts by each respondant to just.one.df
just.one.df <- just.one.df %>% 
  group_by(respondant_name) %>% 
  mutate(rank_weight = rank(-weight, ties.method = "min")) %>% 
  ungroup()

```

## Variation between weightings by respondents

Respondents varied in terms of [the amount of difference]{.underline} they provided for the raw weights of indicators. The figure below shows how much variation there was in the weightings given by each respondent. Respondents with lower standard deviations gave more similar weights to indicators, while those with higher tended to vary much more between indicators.

```{r raw weights sd, echo = F , results="asis", fig.width = 6, fig.height=2, out.height= "30%", caption = "Variation in indicator weights by respondants: respondants with higher standard devidation in their answers varied more between indicators."}
# plotly boxplot of the variation in weights given by each respondant

# calculate the standard deviation of the weights given by each respondant
respondant.sd <- just.one.df %>%
  dplyr::select(respondant_name, weight) %>%
  group_by(respondant_name) %>%
  summarise(sd = sd(weight)) %>%
  arrange(desc(sd))

# ggplot horizontal boxplot of the standard deviation of the weights given by each respondant
respondant.sd.plot <- ggplot(respondant.sd, aes(y = sd, x = 0)) +
  geom_boxplot(width = 0.5, color="grey60", fill = NA,
               outlier.shape = NA) +
  geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                         size = 3, shape = 16,
                         aes(color = respondant_name,
                             tooltip = respondant_name,
                             data_id = respondant_name
                             )
                         ) +
  labs(y = "Standard deviation of weights", x = NULL, title = "Variation by respondent" ) +
  scale_x_continuous(limits = c(-0.3,0.3)) +
  scale_y_continuous(limits = c(0,NA)) +
  scale_colour_manual(values = respondant_colours, name = "Respondant") +
  theme_pubr()+
  theme(plot.title = element_text(size = 12),
        plot.subtitle = element_text(size = 12),
        legend.title = element_text(size = 12 , face = "bold"),
        legend.text =  element_text(size = 9),
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = 12),
        axis.title =  element_text(size = 12),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "right",
        plot.margin = margin(0.5, 1, 0.5, 1, "cm")
  ) +
  coord_flip() 

    girafe(
    ggobj = respondant.sd.plot,
    width_svg = 12,
    height_svg = 4,
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 
    

    
    
```

> Question for respondents: Do you think being more variable in the weights you gave might be appropriate?

### Implications of low weighting variation between-indicators

A lot of respondents provided weights which did not vary to a large degree between indicators. Most respondents, tended not to vary by more than `r median(respondant.sd$sd)` from their average weight. This small variation may be due to a tendency for respondents to consider that "all indicators are important". However, using weights with a small amount of variation will not have a large impact on their relative contribution to the final ecological condition score: essentially all indicators will be treated as being approximately equal in value. While there is nothing technically wrong with this, there is a risk that equal weightings are adopted inadvertently, without full consideration of the potential consequences.

## Exploration of weightings

::: panel-tabset
### Raw weights

Raw weightings varied a lot between respondents for each individual indicator, much more than the variation between the indicators themselves (in terms of their average weight among respondents). This limits how useful the first round of estimated raw weightings will be to differentiate between different indicators importance.

```{r raw weights ggiraph, fig.height= 1,echo = F , results="asis", caption = "Expert opnion indicator weights: estimates for all indicators for all respontants, with boxplots showing the median and inter-quartile range for each indicator."}

#add a col to just.one.df that is the proportion of all of each respondents weight given to each indicator, and one of weights standardised by respondant
just.one.df <- just.one.df %>%
  group_by(respondant_name) %>%
  mutate(weight_share = weight/sum(weight, na.rm = T) * 100,
         weight_standardised = (weight - mean(weight, na.rm = T))/sd(weight, na.rm = T)         ) %>%
  ungroup()

  # Order the levels of sheet_name by the median of rank_weight
ordered_levels <- just.one.df %>%
  group_by(sheet_name) %>%
  summarise(av_weight = median(weight, na.rm = TRUE)) %>%
  arrange(-av_weight) %>%
  pull(sheet_name)

  
# just some background lines to help read the graph
  indicator.lines = data.frame(
    y = rep(c(0,100), each = length(just.one.df$sheet_name %>% unique())),
    sheet_name = rep(just.one.df$sheet_name %>% unique(), times = 2) %>% 
      as.factor()
  ) %>% 
    mutate(sheet_name = factor(sheet_name, levels = ordered_levels))
    
    

  indiv.weights <- ggplot(data = just.one.df %>% 
                            mutate(sheet_name = factor(just.one.df$sheet_name, levels = ordered_levels))) +
    geom_line(data = indicator.lines, color = "grey95",
              aes(x = sheet_name, y = y,
                  data_id = sheet_name),
              show.legend = FALSE) +
    geom_boxplot(aes(x = sheet_name, y = weight), 
               width=0.5, color="grey30", fill = "white", alpha=0.2,
               outlier.shape = NA) +
    geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                           size = 2, shape = 16,
                           aes(x = sheet_name, y = weight,
                               col = respondant_name,
                               alpha = cert_weight,
                               tooltip = paste0(respondant_name, "<br>",sheet_name, "<br>Weight = ", weight, "<br>Certainty = ", cert_weight),
                               data_id = respondant_name #,
                               # text = map(
                               #   paste0("<b>", respondant_name, "</b><br>",
                               #          "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                               # HTML)
                           )) +
    scale_colour_manual(values = respondant_colours, name = "Respondant") +
    scale_y_continuous(limits = c(0,100)) +
    guides(color = F#guide_legend(ncol =1)
           , alpha = F) +
    labs(y = NULL, x = NULL, title = "Indicators weightings") +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 9),
          axis.text.x = element_text(angle = -60, hjust = 0, size = 10),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.box = "vertical",  # Set the legend box to vertical
          legend.position = "right",
          plot.margin = margin(0.2, 0.2, 0.2, 0.2, "cm")
    ) 
  
    girafe(
    ggobj = indiv.weights,
    width_svg = 10,
    height_svg = 6, 
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 

```

### Ranked weights {#sec-rank_weights}

The rank of weightings from each respondent may provide useful information about which indicators are generally considered to be more important than others.

```{r ranked weights ggiraph, echo = F , results="asis", caption = "Expert opnion indicator weights: ranks of indicator importance weightings for all respontants, with boxplots showing the median and inter-quartile range for each indicator's rank."}
  # Order the levels of sheet_name by the median of rank_weight
ordered_levels <- just.one.df %>%
  group_by(sheet_name) %>%
  summarise(median_rank = median(rank_weight, na.rm = TRUE)) %>%
  arrange(median_rank) %>%
  pull(sheet_name)

# Apply the ordered levels to the sheet_name variable
# just.one.df$sheet_name <- factor(just.one.df$sheet_name, levels = ordered_levels)


  indiv.weights <- ggplot(data = just.one.df %>% 
                            mutate(sheet_name = factor(just.one.df$sheet_name, levels = ordered_levels))) +
    geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                           size = 2, shape = 16,
                           aes(x = sheet_name, y = rank_weight,
                               col = respondant_name,
                               alpha = cert_weight,
                               tooltip = paste0(respondant_name, "<br>",sheet_name, "<br>Weight = ", weight, "<br>Weight rank = ", rank_weight, "<br>Certainty = ", cert_weight),
                               data_id = respondant_name #,
                               # text = map(
                               #   paste0("<b>", respondant_name, "</b><br>",
                               #          "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                               # HTML)
                           )) +
    geom_boxplot(aes(x = sheet_name, y = rank_weight), 
             width=0.5, color="grey30", fill = NA,
               outlier.shape = NA) +
    scale_colour_manual(values = respondant_colours, name = "Respondant") +
    scale_y_continuous(limits = c(1,14)) + 
    scale_y_reverse() +
    guides(color = F#guide_legend(ncol =1)
           , alpha = F) +
    labs(y = NULL, x = NULL, title = "Indicators weighting ranks") +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 9),
          axis.text.x = element_text(angle = -60, hjust = 0, size = 10),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.box = "vertical",  # Set the legend box to vertical
          legend.position = "right",
          plot.margin = margin(0.2, 0.2, 0.2, 0.2, "cm")
    ) 
  
    girafe(
    ggobj = indiv.weights,
    width_svg = 10,
    height_svg = 6, 
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 

```

### Standardised weights

Standardised weights of each indicator by respondents, calculated so that all respondents varied the same amount, around the same average (0). This is useful for comparing the relative importance of indicators across respondents, while ignoring the differing variation between indicators given by respondents. However, those differences may be important, and should not be ignored completely.

```{r standardised weights ggiraph, echo = F , results="asis", caption = "Standardised weights: weights given to each indicator by respondents, standardised so that all respondents varied the same amount, with boxplots showing the median and inter-quartile range for each indicator's weight."}
  # Order the levels of sheet_name by the median of rank_weight
ordered_levels <- just.one.df %>%
  group_by(sheet_name) %>%
  summarise(median_standard_weight = median(weight_standardised, na.rm = TRUE)) %>%
  arrange(-median_standard_weight) %>%
  pull(sheet_name)

# Apply the ordered levels to the sheet_name variable
# just.one.df$sheet_name <- factor(just.one.df$sheet_name, levels = ordered_levels)

 indiv.weights <- ggplot(data = just.one.df %>% 
                            mutate(sheet_name = factor(just.one.df$sheet_name, levels = ordered_levels))) +
    geom_point_interactive(position = position_jitter(width = 0.2, height = 0),
                           size = 2, shape = 16,
                           aes(x = sheet_name, y = weight_standardised,
                               col = respondant_name,
                               alpha = cert_weight,
                               tooltip = paste0(respondant_name, "<br>",sheet_name, "<br>Weight = ", weight, "<br>Weight rank = ", rank_weight, "<br> Standardised weight = ", weight_standardised, "<br>Certainty = ", cert_weight),
                               data_id = respondant_name #,
                               # text = map(
                               #   paste0("<b>", respondant_name, "</b><br>",
                               #          "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                               # HTML)
                           )) +
    geom_boxplot(aes(x = sheet_name, y = weight_standardised), 
             width=0.5, color="grey30", fill = NA,
               outlier.shape = NA) +
    scale_colour_manual(values = respondant_colours, name = "Respondant") +
    # scale_y_continuous(limits = c(1,14)) + 
    guides(color = F#guide_legend(ncol =1)
           , alpha = F) +
    labs(y = NULL, x = NULL, title = "Standardised weightings by respondant") +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 9),
          axis.text.x = element_text(angle = -60, hjust = 0, size = 10),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.box = "vertical",  # Set the legend box to vertical
          legend.position = "right",
          plot.margin = margin(0.2, 0.2, 0.2, 0.2, "cm")
    ) 
  
    girafe(
    ggobj = indiv.weights,
    width_svg = 10,
    height_svg = 6, 
    options = list(
      opts_hover_inv(css = "stroke-opacity:0.01;"),
      opts_hover(css = "stroke:orange;stroke-width:5;fill-opacity:1")
    ) ) 
    

```


### Indicator weightings data summary

```{r caption = "*the average prortion of each respondants' sum weights given to each indicator."}



column_names <- c("Indicator", "Average weight", "Average weight rank (lower better)", "Average standardised weight","Ranked most important \n(% responants)", "Ranked least important (% responants)"
                  #, "Sum of Ranks (lower better)"
                  )

DT::datatable(just.one.df %>%
                group_by(sheet_name) %>%
                summarise(
                  av_weight = round(mean(weight, na.rm = T), 0),
                  av_rank_weight = round(mean(rank_weight, na.rm = T), 0),
                  ave_weight_standardised = round(mean(weight_standardised, na.rm = T), 0),
n_rank_1 = round(sum(rank_weight == 1)/ n() * 100),
                  n_lowest = round(sum(rank_weight == max(rank_weight, na.rm = T))/ n() * 100)# but rank is ordered, so actually this is the "min"
#,
                  # sum_rank_weight = sum(rank_weight, na.rm = T),
                  ) %>%
                arrange(-av_weight) %>%
                mutate(sheet_name = paste0("<b>", sheet_name, "</b>")),
              rownames = F,
              escape = F,
              colnames = column_names,  # Specify column names
              options = list(
                dom = 't',
                paging = F,
                ordering = T,
                searching = F,
                info = F,
                columnDefs = list(list(width = '100px', targets = "_all"))
              )
) 


```

:::

### Conculsions from round 1 weightings estiamtes

There was too much variation in raw weightings between respondents to draw many useful conclusions from that data directly.

The rankings of indicators by their importance, and the shares of importance given to each indicator also exhibited a lot of variation between respondents, but there were a few general trends worth noting (to which there are many exceptions):

-   Deadwood and horizontal complexity were generally ranked highest
-   Tree health and woodland extent generally ranked low, and the lowest by many respondents

## Patterns between respondents

The context within which respondents work might have a large impact on their sense for which indicators are more or less important. The plots below explore this by looking for trends and groupings between respondents, to add further context and help respondents determine where their own responses may be based on experiences that are less relevant to more "typical" woodland. In the later case, they may wish to alter their weightings and provide further input via a comment/exception to their general estimation.

### Heatmaps 

::: panel-tabset
#### Raw weightings

```{r heatmap function}
library(heatmaply)

generate_interactive_heatmap <- function(data, weight_variable) {
  # Select relevant columns and spread the data
  weights.mat <- data %>%
    dplyr::select(respondant_name, sheet_name, !!sym(weight_variable)) %>%
    spread(sheet_name, !!sym(weight_variable)) %>%
    # Make respondant_name the row names
    column_to_rownames(var = "respondant_name") %>%
    na.omit() %>% # Filter out rows with all NA
    as.matrix()

  # Generate interactive heatmap
  heatmaply(weights.mat,
            # Dendrogram = "row",
            xlab = "", ylab = "",
            main = "",
            scale = "column",
            margins = c(60, 100, 40, 20),
            grid_color = "white",
            grid_width = 0.00001,
            titleX = FALSE,
            hide_colorbar = TRUE,
            branches_lwd = 0.1,
            label_names = c("Respondent", "Feature:", "Value"),
            fontsize_row = 5, fontsize_col = 5,
            labCol = colnames(weights.mat),
            labRow = rownames(weights.mat),
            heatmap_layers = theme(axis.line = element_blank())
  )
}


```

```{r heatmap weights raw, echo = F, results="asis"}
generate_interactive_heatmap(just.one.df, "weight")
```

#### Ranked weightings

```{r heatmap rank weights, echo = F, results="asis"}
generate_interactive_heatmap(just.one.df, "rank_weight")
```

:::

### Principle Component analysis

```{r PCA function}
library(factoextra)
library(FactoMineR)

generate_interactive_PCA <- function(data, weight_variable) {
  # Select relevant columns and spread the data
  weights.mat <- data %>%
    dplyr::select(respondant_name, sheet_name, !!sym(weight_variable)) %>%
    spread(sheet_name, !!sym(weight_variable)) %>%
    # Make respondant_name the row names
    column_to_rownames(var = "respondant_name") %>%
    na.omit() %>% # Filter out rows with all NA
    as.matrix()

  # Generate PCA
  pca <- PCA(weights.mat, graph = F)

  # Generate interactive PCA
  fviz_pca_biplot(pca, repel = TRUE,
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969",  # Individuals color
                geom.ind = "point",
                col.quanti.sup = "black",
                col.ind.sup = "black",
                  col.var.sup = "black",
                  pointsize = 1,
                  title = "",
                  axes = c(1, 2),
                  addEllipses = TRUE,
                  ellipse.level = 0.95,
                  labelsize = 3,
                  legend.title = "",
                  legend.position = "none",
                  legend.justification = "none",
                  legend.direction = "none",
                  legend.box = "none",
                  repel.max.iter = 1000,
                  repel.strength = 0.1,
                  repel.seed = 123,
                  ggtheme = theme_pubr()
  )
}

```
::: panel-tabset
#### Raw weightings

```{r PCA weights raw, echo = F, results="asis"}
generate_interactive_PCA(just.one.df, "weight")
```
#### Ranked weightings

```{r PCA rank weights, echo = F, results="asis"}
generate_interactive_PCA(just.one.df, "rank_weight")
```

:::
