---
title: "Assessing Woodland Ecological Condition"
date:    |
  `r format(Sys.time(), '%d %B, %Y')`
output: 
  html_document:
    toc: true
    toc_float: true
    theme: united
---
<style>
.html-widget {
  max-width: 1000px;
  margin: auto;
}
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r global-options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=5, fig.path='Figs/',
                      echo=FALSE, warning=FALSE, message=FALSE)
forms.direct <- "Data\\Delphi round 1\\response sheets\\"
extraction.location <- "Data\\Delphi round 1\\"

```

# Introduction  

```{r data_extraction_from_excelsheets - preliminary work, echo = F, include = F, eval = F }

# ---------------------------------------------------------------
# RUN SCRIPT TO EXTACT FROM EXCEL SHEETS ----------------------------------
# ---------------------------------------------------------------
source("Scripts\\Extract_expert_info.R")
# if all is well this should:
# save ind.matcher ind.matcher.df and expert.data (expert opinion responses from the Delphi forms) 
# as files within the specified extraction.location to be loaded together
# then later I loads it (in Italian-American mafiosi accent)
```

```{r libraries_data, echo = F, include = F, eval = T }

# LIBARIES ---------------------------------------------------------------
library(readxl)
library(tidyverse)
library(stringr)
library(plotly)
library(ggpubr)
library(mgcv)
library(RColorBrewer)
library(htmltools)
library(htmlwidgets)
library(gridExtra)
library(grid)
library(DT)
library(Polychrome)


#-----------------------------------------------------
#  LOAD DATA ----------------------------------------------

load(paste0(extraction.location,"sheets_data.RData"))

# ---------------------------------------------------------------
# ok, that was "fun", lets get to woooork!

```
```{r data_curation, echo = F, include = F, eval = T }
#-----------------------------------------------------
# DATA CURATION --------------------------------------------------
#-----------------------------------------------------
## Create a data frame of respondant data ------------
# Step 1: Extract data from expert.data list
respondent_names <- expert.data$respondant_name %>% unlist
indicator_nums <- expert.data$indicator_num %>% unlist
indicator_names <- expert.data$indicator_name %>% unlist
cert_val_funct <- expert.data$value_confidence_score %>% unlist
measure <- unlist(lapply(expert.data$value.points, `[[`, "measure"))
value <- unlist(lapply(expert.data$value.points, `[[`, "value"))
weight <- expert.data$weight_indicy_score %>% unlist()
cert_weight <- expert.data$weight_indicy_confidence %>% unlist()
vf.sentance <- expert.data$descriptive_sentance %>% unlist()

# Create a data frame by combining the data, scale and add variables
# 
df <- data.frame(
  respondant_name = rep(respondent_names, sapply(expert.data$value.points, nrow)),
  indicator_num = rep(indicator_nums, sapply(expert.data$value.points, nrow)),
  indicator_name = rep(indicator_names, sapply(expert.data$value.points, nrow)),
  
  measure = measure,
  value = value,
  cert_val_funct = rep(cert_val_funct, sapply(expert.data$value.points, nrow)),
  vf.sentance = rep(vf.sentance, sapply(expert.data$value.points, nrow)),
  
  weight = rep(weight, sapply(expert.data$value.points, nrow)),
  cert_weight = rep(cert_weight, sapply(expert.data$value.points, nrow)),
  
  stringsAsFactors = FALSE
) %>% merge(., ind.matcher.df, by.x = "indicator_name", by.y = "indicator_name", all.x = T) # this is wrong -- its sheet name.. but its fine


## scale and augment ----

df.scaled <- df %>% 
  group_by(indicator_name, respondant_name) %>% 
  mutate(value = ((value - min(value)) * 100)/ (max(value) - min(value)) # scale by min and max value for each respondant 
        ) 
df.scaled <- df.scaled %>% 
  group_by(respondant_name) %>% 
  mutate(weight = weight * (100 / max(weight)) # scale by biggest value for each respondant 
  )

which.scaled.VF <- paste(df$respondant_name, "-", df$indicator_name)[df.scaled$value != df$value] %>% 
  sort() %>%   unique()
which.scaled.wt <- paste(df$respondant_name)[df.scaled$weight != df$weight] %>% 
  sort() %>%   unique()

df$value <- df.scaled$value %>% round(0)
df$weight <- df.scaled$weight %>% round(0)

weight.rank <-  df[!duplicated(paste0(df$indicator_name, df$respondant_name)),] %>% arrange(respondant_name, weight) %>%
    group_by(respondant_name) %>%
    mutate(weight_rank = rank(-weight)) %>% 
  dplyr::select(c("indicator_name", "respondant_name", "weight_rank"))
df <- df %>% right_join(weight.rank, by = c("indicator_name", "respondant_name"))

df$value.dec = df$value/100 # a decimal version of value to work in the later binomial gams

  respondant_colours <- glasbey.colors(nlevels(as.factor(df$respondant_name))+1)[-1] %>% # a colour for each respondant, but not white
    as.character()

df$respondant_colour <- respondant_colours[df$respondant_name %>% 
                                             as.factor() %>% unclass() %>%
                                             as.numeric()] # number each respondant


## version with sinlge entry for each indicator:respondant ----
just.one.df <- df[!duplicated(paste0(df$sheet_name, df$respondant_name)),
c("indicator_name", "respondant_name", "cert_val_funct", "cert_weight", "sheet_name", "weight")]

just.one.df$mean_repond_cert_vf <- ave(just.one.df$cert_val_funct, just.one.df$respondant_name, FUN = function(x) mean(x, na.rm = TRUE))
just.one.df$mean_repond_cert_wt <- ave(just.one.df$cert_weight, just.one.df$respondant_name, FUN = function(x) mean(x, na.rm = TRUE))
#-----------------------------------------------------

```
```{r participation_data_curation, echo = F, include = F, eval = T }


# completed df
has_completed <- data.frame(respondent_names = respondent_names,
                            indicator_name = indicator_names,
                            wt = !is.na(weight),
                            wt_cert = !is.na(cert_weight),
                            vf = sapply(expert.data$value.points, nrow)>1,
                            vf_cert = !is.na(as.numeric(cert_val_funct))
                            ) %>% 
  left_join(., ind.matcher.df[, c("sheet_name", "indicator_name")], by = "indicator_name")

# create df of group by(indicator, respondant) %>% sum(completed) for each
completed_summary <- has_completed %>% 
  group_by(respondent_names) %>% 
  summarize(vf = sum(vf),
            vf_cert = sum(vf_cert),
            wt = sum(wt),
            wt_cert = sum(wt_cert))
```
```{r functions to make value function plots, echo = F }

# FUNCTION - PLOT RESPONDANTS' continuous INDICATOR VFs ----
  ggplot_gam_resp_vf <- function(indicator_name, gam.col = "black", x.lab = ind.matcher.df$ind.axis.title[i]){
          # Filter the data for the selected indicator
  filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
    mutate(respondant_name = as.factor(respondant_name))
  ## Color palette
  respondant_colours <- glasbey.colors(nlevels(as.factor(filtered_data$respondant_name))+1)[-1] %>% as.character()
  # respondant_colours <- brewer.pal(nlevels(as.factor(filtered_data$respondant_name)),  "Paired")

  # PREDICT TREND ----
  filtered_data$point.influence <- 1/(table(filtered_data$respondant_name)[as.factor(filtered_data$respondant_name)]) %>% 
    as.numeric()
  gam_model <- gam(value.dec ~ s(measure, k = 4),
                        data = filtered_data, family = binomial(), weights = point.influence)
  # Create dummy data for prediction
  dummy_data <- data.frame(measure = seq(min(filtered_data$measure), max(filtered_data$measure), length.out = 50))
  # Predict using the GAM model
  dummy_data$predicted_value <- predict(gam_model, newdata = dummy_data, type = "response")*100

  # PLOT SPEC, LINES AND TREND ----
  plot <- ggplot() +
    geom_line(data = dummy_data, size = 2, aes(y = predicted_value, x = measure), colour = gam.col) + # gam prediction
    geom_line(data = filtered_data, 
              aes(x = measure, y = value, color = respondant_name,
                  text = map(
                    paste0("<b>", `respondant_name`, "</b>",
                           "<br><b>Certainty:</b>", cert_val_funct, "<br>",
                           "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"#,
                           #"<b>Sentance: </b>", vf.sentance
                           ),
                    HTML),
                  alpha = cert_val_funct),
              size = 0.5) +
    geom_point(data = filtered_data, 
               size = 2, shape = 16,
               aes(x = measure, y = value, color = respondant_name,
                   text = map(
                     paste0("<b>", `respondant_name`, "</b>",
                            "<br><b>Certainty:</b>", cert_val_funct, "<br>",
                            "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"#,
                   #        "<b>Sentance: </b>", vf.sentance
                   ),
                     HTML),
                   alpha = cert_val_funct)) +
    scale_colour_manual(values = respondant_colours) +
    labs(title = indicator_name, x = x.lab, y = "Value Score",
         colour = "Respondant") +
    guides(alpha = F) +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 12),
          axis.text.x = element_text(size = 12),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.position = "right",
          plot.margin = margin(0.5, 1, 0.5, 1, "cm")
    ) 
  
  plot
  }

# FUNCTION - PLOT RESPONDANTS' CATEGORICAL INDICATOR VFs ----
  ggplot_resp_cat_vf <- function(indicator_name, x.lab = ind.matcher.df$ind.axis.title[i], data = vf_cat_data){
    # vf_cat_data is filtered_data, formatted to include categories - cat_measure
    
  ## Color palette
  respondant_colours <- glasbey.colors(nlevels(as.factor(filtered_data$respondant_name))+1)[-1] %>% as.character()
  # respondant_colours <- brewer.pal(nlevels(as.factor(filtered_data$respondant_name)),  "Paired")

  # PLOT SPEC, LINES AND TREND ----
  plot <- ggplot() +
    geom_boxplot(data = data, 
              aes(x = cat_measure, y = value), text = NULL) +
      stat_summary(data = data, aes(x = cat_measure, y = value),
               geom = "point", fun = mean,
               color = "red", shape = 3, size = 5,
               position = position_nudge(x = 0.05, y = 0)
               ) +
    stat_summary(fun=mean, geom='point', shape=20, size=8) +
    geom_jitter(data = data, 
               size = 2, shape = 16,
               position=position_jitter(width=.1, height=0),
               aes(x = measure, y = value, color = respondant_name,
                   text = map(
                     paste0("<b>", `respondant_name`, "</b>",
                            "<br><b>Value:</b>", value, "<br>",
                            "<br><b>Certainty:</b>", cert_val_funct, "<br>",
                            "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                     HTML),
                   alpha = cert_val_funct)) +
    scale_colour_manual(values = respondant_colours) +
    labs(title = indicator_name, x = x.lab, y = "Value Score",
         colour = "Respondant") +
    guides(alpha = F) +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 12),
          axis.text.x = element_text(size = 12),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          legend.position = "right",
          plot.margin = margin(0.5, 1, 0.5, 1, "cm")
    ) 
  
  plot
  }

# FUNCTION - PLOT RESPONDANTS' WEIGHTS - FOR INDICATOR  ----
  ggplot_resp_weight_ind <- function(indicator_name){
    # plot weights by respondant for this indicator
# Filter the data for the selected indicator
  filtered_data <- df[df$indicator_name == indicator_name & !duplicated(paste0(df$respondant_name, df$indicator_name)), ] %>% 
    mutate(respondant_name = as.factor(respondant_name))
  ## Color palette
  respondant_colours <- glasbey.colors(nlevels(as.factor(filtered_data$respondant_name))+1)[-1] %>% as.character()

  # PLOT SPEC, LINES AND TREND ----
  plot <- ggplot(filtered_data) +
    geom_boxplot(aes(x = 0, y = weight)) +
      stat_summary(data = filtered_data,
                   aes(x = 0, y = weight),
                   geom = "point", fun = mean,
                   color = "red", shape = 3, size = 5) +
    geom_jitter(aes(x = 0, y = weight, color = respondant_name,
               text = map(
                     paste0("<b>", `respondant_name`, "</b><br>",
                            "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>",
                            "<b>Weight rank: </b>", weight_rank),
                     HTML),
                   alpha = cert_weight), 
               size = 2, shape = 16,
               position=position_jitter(width=.1, height=0)) +
    scale_colour_manual(values = respondant_colours) +
    scale_y_continuous(limits = c(0,100)) +
    labs(y = "Weight",
         colour = "Respondant") +
    guides(alpha = F) +
    theme_pubr()+
    theme(plot.title = element_text(size = 12),
          plot.subtitle = element_text(size = 12),
          legend.title = element_text(size = 12 , face = "bold"),
          legend.text =  element_text(size = 12),
          axis.text.y = element_text(size = 12),
          axis.title =  element_text(size = 12),
          axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          legend.position = "right",
          plot.margin = margin(0.5, 1, 0.5, 1, "cm")
    ) 
  
  plot
  }
  
```


This document explores the expert opinion gathered from staff at the Woodland Trust, related to the measurement of `r has_completed$indicator_name %>% unique() %>% length()` indicators of woodland ecological condition, and the relationship between these indicators' and a wood's potential to promote flourishing wildlife species communities (by estimating "value functions" and importance weightings for each indicator). 

Expert opinion on the value function and weight for each indicator was elicitated using the Delphi method. The Delphi method is designed to collect and distill expert knowledge, using repeated surveys to refine estimates, increasing their reliability 
<!-- (Edwards et al., 2011) -->
and identifying where agreements and disagreements in understanding occur.   
<!-- (Buckley, 1995; Kangas, Alho, Kolehmainen, & Mononen, 1998; Landeta, 2006). --> 
  
The method relies on repetitive surveying in at least two to three ‘rounds’ where participants are asked the same questions. After each round participants review and consider the answers given by all panel-members, and are then given the opportunity to revise their answers. The Delphi method has a history of successful use in supporting conservation action where empirical evidence is insufficient and information is needed rapidly to inform decisions. It's transparency and repeatability also add to its appeal.  

Each participant either attended an introductory workshop to the process, or was taken through individually. A sub-section of participants were also involved in development the proposed methods to measure each indicator in the field. Answers were submitted into individual Excel spread sheets, with questions relating to:  

- Value functions describing how each indicator related to WEC, in typical conditions
- Weightings decreeing the relative important of each indicator to WEC, in typical conditions
- Certainty around value function and weighting estimates (subjective score 0-5)
- Comments or concerns relating to: situations where these "typical" responses might be inappropriate, the proposed method to measure indicators, and any other relevant information.  

Participants were encouraged to keep a clear distinction between the quantitative responses provided (i.e. value functions and weightings under typical conditions) and exceptions to those typical relationships (that they highlighted in their comments).  

It was also stated that noted exceptions would be analysed and, where appropriate, used to inform future development of the WEC measure to account for important nuance.


# Indicators considered  

```{r  indicators table, echo = F }
ind.table <- ind.matcher.df [,1:2]
names(ind.table) <- c("Indicator", "Description")
ind.table %>% 
   datatable(extensions = c('FixedColumns',"FixedHeader"),
              options = list(scrollX = T, 
                             paging = F,
                             fixedHeader=F,
                             dom = 't',
                             fixedColumns = list(leftColumns = 1) #,
                             # fixedColumns = list(leftColumns = 1) ,
                             # buttons = c('copy', 'csv')
                             ),
              rownames = F#,
              #container = sketch.lcm.areas
              ) %>% 
    formatStyle( columns = c("Indicator"), fontWeight = 'bold', `text-align` = 'left', "white-space" = "nowrap")# %>% 


```


# Analysis Method
### Scaling

Values and weights are all measured relative to each other. Some respondents did not use the full 0 to 100 range for all value functions and weights. Comparison between participants requires that they all use the same scale, and so all value functions where scaled from 0 to 100 and weightings were scaled so that the highest indicator weighting for each panelist was 100.

<button class="btn btn-primary" data-toggle="collapse" data-target="#BlockName"> Show/Hide details of responses requiring scalling </button>  
<div id="BlockName" class="collapse">  


**Value functions** scaled for:  
`r paste0("<br>- ", which.scaled.VF)`  

**Weights** were scaled for:  

`r paste0("<br>- ", which.scaled.wt)`  

### Edits to responses

In some cases - where appropriate to allow categorisation - points were added to value functions by visual interpolation. Some points where also added by extrapolation where a maximum/minimum value was clearly implied.  


### Displaying of results

A copy of this report was circulated to respondents between rounds to allow respondents to investigate estimates provided by others, and their certainties.

Where appropriate value functions where plotted categorically (with box plots summarising the estimated value at each category), and continuously (with lines connecting points and an indication of the general trend - see model details below). Indicator relative weightings were presented on boxplots, including the mean and median estimates. Interactive hover-text displayed respondent name and their certainty in their estimate.

#### Model details

Value functions were modeled with a binomial GAM. The influence of points from each respondent weighted by the inverse of the number of points provided by that respondent, with the aim of ensuring that all respondents had the same influence on the result, regardless of how many points they provided.


# Participants and survey completion{.tabset .tabset-fade .tabset-pills}

`r has_completed$respondent_names %>% unique() %>% length()` expert practitioners from Woodland Trust and Plantlife staff were invited to provide their opinion the value and weight of indicators.  
`r sum(completed_summary[,2:5] %>% rowSums() >0)` have provided a response as of `r date()`.   
Of these, `r sum((completed_summary[,2:5] %>% rowSums() >0) & (completed_summary[,2:5] %>% rowSums() < (4* has_completed$indicator_name %>% unique() %>% length() ) ))` remain partially incomplete.  

## Survey completion summary  
The chart below summarises participant completion of different elements of the survey. For more detail see table (button below chart).

``` {r  participation_chart - make, echo = F, eval = F }

# use df to ggplot
# The first legitimate use of a pie chart in my carer!

max_count = max(completed_summary$vf)

create_gg_pie_chart <- function(count, max_count) {
  percentage <- count / max_count * 100
  pie_chart <- ggplot(data.frame(x = c("Done", "Remaining"), y = c(count, max_count - count)),
                      aes(x = "", y = y, fill = x)) +
    geom_bar(width = 1, stat = "identity") +
    scale_fill_manual(values = c("steelblue", "lightgray")) +  # Specify custom colors
    coord_polar(theta = "y") +
    theme_void() +
    theme(legend.position = "none")
  
  return(pie_chart)
  
  pie_matrix <- arrangeGrob(grobs = gg_pie_charts, nrow = length(completed_summary$respondent_names), ncol = length(colnames(completed_summary[, c("wt", "wt_cert", "vf", "vf_cert")])))
# Add row names (respondent names)
row_names <- completed_summary$respondent_names

# Add column names
col_names <- c("Value func", "VF cert", "Weights", "wt cert")

combine <- rbind(tableGrob(t(c(col_names)), theme = ttheme_minimal(), rows = ""), 
                 cbind(tableGrob(row_names, theme = ttheme_minimal()), 
                       arrangeGrob(grobs = gg_pie_charts, nrow = length(row_names), ncol = length(col_names)),  size = "last"), size = "last")
}

gg_pie_charts <- list(NA)
bk = 1
for (i in 1:(length(completed_summary$respondent_names))){
  for (ii in 1:(dim(completed_summary)[2]-1)){
    count <- completed_summary[i,1+ii] %>% as.numeric()
    gg_pie_charts[[bk]] <-  create_gg_pie_chart(count, length(unique(df$indicator_name)))
  bk = bk+1
    }}
  
save(combine, file = "Figs//gg_pie_charts.RData")

```
``` {r  participation_chart - plot, echo = F }
load(file = "Figs//gg_pie_charts.RData")

# Convert the list of pie charts to a grid using grid.arrange

grid.newpage()
grid.draw(combine)

```
Figure 1. Completion of expert opinion survey components by each panelist (coloured portion of pies) for value functions ("Value func"), value function certainties ("VF cert"), indicator weightings ("Weights") and weighting certainties ("wt certs").  

## Survey completion details  

```{r what needs done by participants details, eval = F}

# Create a data frame with participant names and the four columns
participant_table <- data.frame(respondent_names = completed_summary$respondent_names,
                                vf = "",
                                vf_cert = "",wt = "",
                                wt_cert = "",
 stringsAsFactors = FALSE)

# Iterate over each participant and update the table with the indicators not completed
for (i in 1:nrow(completed_summary)) {
  n.indicators <- has_completed$indicator_name %>% unique() %>% length()
  participant <- completed_summary[i, "respondent_names"] %>% as.character()
  not_completed_wt <- has_completed$sheet_name[has_completed$respondent_names == participant & has_completed$wt == FALSE]
  not_completed_wt_cert <- has_completed$sheet_name[has_completed$respondent_names == participant & has_completed$wt_cert == FALSE]
  not_completed_vf <- has_completed$sheet_name[has_completed$respondent_names == participant & has_completed$vf == FALSE]
  not_completed_vf_cert <- has_completed$sheet_name[has_completed$respondent_names == participant & has_completed$vf_cert == FALSE]
  
  if (length(not_completed_wt) == n.indicators) not_completed_wt <- "all"
  if (length(not_completed_wt_cert) == n.indicators) not_completed_wt_cert <- "all"
  if (length(not_completed_vf) == n.indicators) not_completed_vf <- "all"
  if (length(not_completed_vf_cert) == n.indicators) not_completed_vf_cert <- "all"

  participant_table[participant_table$respondent_names == participant, "wt"] <- paste(not_completed_wt, collapse = ", ")
  participant_table[participant_table$respondent_names == participant, "wt_cert"] <- paste(not_completed_wt_cert, collapse = ", ")
  participant_table[participant_table$respondent_names == participant, "vf"] <- paste(not_completed_vf, collapse = ", ")
  participant_table[participant_table$respondent_names == participant, "vf_cert"] <- paste(not_completed_vf_cert, collapse = ", ")
}

# Print the participant table

names(participant_table) <- c("Respondent", "Value Functions", "vf certs", "Weights", "wt certs")

participant_table %>%  
    datatable(extensions = c('FixedColumns',"FixedHeader"),
              options = list(scrollX = T, 
                             scrollY = '400px',  # Set the desired height for the table
                             scrollCollapse = TRUE,

                             paging = F,
                             fixedHeader=F,
                             dom = 't',
                             autoWidth = TRUE, fixedColumns = list(leftColumns = 1) #,
                             # fixedColumns = list(leftColumns = 1) ,
                             # buttons = c('copy', 'csv')
                             ),
              rownames = F#,
              #container = sketch.lcm.areas
              ) %>% 
    formatStyle( columns = c("Respondent"), fontWeight = 'bold', `text-align` = 'left', "white-space" = "nowrap")# %>% 

```

# Reponses by indicator  

## Tree age/size distribution {.tabset .tabset-fade .tabset-pills}
```{r vf Tree age size distribution - init, echo = F , results="asis"}

ind.num = 1
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Tree age size distribution - categorical, echo = F , results="asis"}

categorised_vf_fig <- function(){
  # categorical plot
vf_cat_data = filtered_data %>% 
                     mutate(cat_measure = as.factor(measure))
plot <- ggplot_resp_cat_vf(indicator_name = indicator_name,
                    x.lab = ind.axis.title,
                   data = vf_cat_data )

ggsave(filename = paste0("Figs//ind_",
                         formatC(ind.num, width = 2, format = "d", flag = "0"),
                         "_", indicator_name, "vf_boxplot.png"),
       plot = plot,
       width = 300, height = 150, units = "mm")
##ggplotly
ggplotly(plot, tooltip = "text", dynamicTicks = F) %>% 
    config(displayModeBar = F) %>% 
    layout(yaxis = list(range = c(-5, 105)))
}

categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```

### Continuous Value function
```{r vf Tree age size distribution - continuous, echo = F , results="asis"}


continuous_vf_fig <- function(line.col = NA){
  plot <- ggplot_gam_resp_vf(indicator_name = indicator_name,
                           x.lab = ind.axis.title, gam.col = line.col)

ggsave(filename = paste0("Figs//ind_",
                         formatC(ind.num, width = 2, format = "d", flag = "0"),
                         "_", indicator_name, "vf_continuous.png"),
       plot = plot,
       width = 300, height = 150, units = "mm")

ggplotly(plot, tooltip = "text", dynamicTicks = F) %>% 
    config(displayModeBar = F) %>% 
    layout(yaxis = list(range = c(-5, 105)))
}
  
continuous_vf_fig()

```

### Weights
```{r vf Tree age size distribution - weights, fig.width= 4, echo = F , results="asis"}

weights_fig <- function(){
  wt.plot <- ggplot_resp_weight_ind(indicator_name = indicator_name)

ggsave(filename = paste0("Figs//ind_",
                         formatC(ind.num, width = 2, format = "d", flag = "0"),
                         "_", indicator_name, "weights.png"),
       plot = wt.plot,
       width = 300, height = 150, units = "mm")


ggplotly(wt.plot, tooltip = "text", dynamicTicks = F) %>% 
    config(displayModeBar = F) %>% 
    layout(yaxis = list(range = c(-5, 105)))
}

weights_fig()
```

## {-}

### Comments

Consensus on VF likely:  
- All continuous relationships have same shape.  
- Complete agreement on upper and lower value.  
- Some put maximum value at 3 classes.  

Disagreement on weight:  
- Two camps, giving relatively low and high weights (compared to other indicators) at c. 60 and 90, respectively.  


## Canopy nativness {.tabset .tabset-fade .tabset-pills}

```{r vf Canopy Nativness - init, echo = F , results="asis"}

ind.num = 2
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Continuous Value function
```{r vf Canopy Nativness - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Canopy Nativness - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments  

VF:  
- Similar trends. Some prefer linear, some S-shaped, some exponential, some logarithmic
- Bit of disagreement RE requirement for max value

Weightings: fairly wide spread
 

## Vertical Structure {.tabset .tabset-fade .tabset-pills}

Of four possible categories: >15m; 5-15m; 2-5m; 0.5-2m; measured at plot level

```{r vf Vertical Structure - init, echo = F , results="asis"}

ind.num = 3
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Vertical Structure - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Vertical Structure - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Vertical Structure - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Native tree an shrub species richness {.tabset .tabset-fade .tabset-pills}

```{r vf Native tree an shrub species richness - init, echo = F , results="asis"}

ind.num = 4
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Native tree an shrub species richness - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Native tree an shrub species richness - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Native tree an shrub species richness - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Invasives {.tabset .tabset-fade .tabset-pills}

```{r vf Invasives - init, echo = F , results="asis"}

ind.num = 5
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Invasives - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Invasives - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Invasives - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Deadwood {.tabset .tabset-fade .tabset-pills}

```{r vf Deadwood - init, echo = F , results="asis"}

ind.num = 6
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Deadwood - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Deadwood - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Deadwood - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## AVTs {.tabset .tabset-fade .tabset-pills}

```{r vf AVTs - init, echo = F , results="asis"}

ind.num = 7
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf AVTs - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf AVTs - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf AVTs - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Woodland Extent {.tabset .tabset-fade .tabset-pills}

```{r vf Woodland Extent - init, echo = F , results="asis"}

ind.num = 8
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Woodland Extent - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Woodland Extent - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Woodland Extent - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Regeneration {.tabset .tabset-fade .tabset-pills}

```{r vf Regeneration - init, echo = F , results="asis"}

ind.num = 9
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Regeneration - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Regeneration - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Regeneration - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Herbivore Impact {.tabset .tabset-fade .tabset-pills}

```{r vf Herbivore Impact - init, echo = F , results="asis"}

ind.num = 10
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Herbivore Impact - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Herbivore Impact - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Herbivore Impact - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Tree Health {.tabset .tabset-fade .tabset-pills}

```{r vf Tree Health - init, echo = F , results="asis"}

ind.num = 11
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Tree Health - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Tree Health - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Tree Health - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Ground Flora {.tabset .tabset-fade .tabset-pills}

```{r vf Ground Flora - init, echo = F , results="asis"}

ind.num = 12
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Ground Flora - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Ground Flora - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Ground Flora - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Horizontal complexity {.tabset .tabset-fade .tabset-pills}

```{r vf Horizontal complexity - init, echo = F , results="asis"}

ind.num = 13
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Horizontal complexity - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Horizontal complexity - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Horizontal complexity - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments


## Human Damage {.tabset .tabset-fade .tabset-pills}

```{r vf Human Damage - init, echo = F , results="asis"}

ind.num = 14
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
indicator_name  

filtered_data <- df[df$indicator_name == indicator_name, ] %>% 
  mutate(respondant_name = as.factor(respondant_name))

paste(length(unique(filtered_data$respondant_name)), "respondants.")
```

### Categorised value function
```{r vf Human Damage - categorical, echo = F , results="asis"}
categorised_vf_fig()

## table
filtered_data %>%
  group_by(measure) %>%
  summarise(Mean = mean(value, na.rm = TRUE) %>% round(digits = 1),
            'Standard deviation' = sd(value, na.rm = TRUE) %>% round(digits = 1)) %>% 
knitr::kable()

```
### Continuous Value function
```{r vf Human Damage - continuous, echo = F , results="asis"}
continuous_vf_fig()
```

### Weights
```{r vf Human Damage - weights, fig.width= 4, echo = F , results="asis"}

weights_fig()
```

## {-}

### Comments

# plot all indicators sequentially

```{r vf plot vfs, echo = F , results="asis"}
# CREATE VF PLOTS ----
each.plotly <- list(NA)

for(i in 1: length(ind.matcher.df$indicator_name)){
  
  plot <- ggplot_gam_resp_vf(indicator_name = ind.matcher.df$indicator_name[i])
  
  plotly <- ggplotly(plot, tooltip = "text", dynamicTicks = F) %>% 
    config(displayModeBar = F) %>% 
    layout(yaxis = list(range = c(-5, 105)))

  each.plotly[[i]] <- plotly
  
  }

# print some set text (a title) and the vf figure
for (i in 1:length(ind.matcher.df$indicator_name)) {
  cat("###", ind.matcher.df$sheet_name[i], "\n\n")
   print(htmltools::tagList(each.plotly[[i]] ))
   cat('\n')
}


```
```{r vf 2plot vfs, echo = F , results="asis"}

   # exceptions <- expert.data$value_func_exceptions[expert.data$indicator_num %>% unlist()==i] 
   # respondants <- expert.data$respondant_name[expert.data$indicator_num %>% unlist()==i] %>% unlist()
   # 
   # for ( ii in 1:sum(lengths(exceptions)>0) ){
   #   cat("*",respondants[lengths(exceptions)>0][ii], "*  ")
   #   exceptions[lengths(exceptions)>0][ii] %>% unlist()
   #   }

# }
# 
#  cat("  \n###",  month.name[i], "Air Quaility  \n")
#   #print(plot(airquality[airquality$Month == i,]))
#   plot(airquality[airquality$Month == i,])
#   cat("  \n")
# 
# 



# i <- 1
# 
# each.plotly[[i]]
# 
# exceptions <- expert.data$value_func_exceptions[expert.data$indicator_num %>% unlist()==i] 
# respondants <- expert.data$respondant_name[expert.data$indicator_num %>% unlist()==i] %>% unlist()
# 
# respondants[lengths(exceptions)>0]
# 
# for ( ii in 1:sum(lengths(exceptions)>0) ){
#   print(paste0("*",respondants[lengths(exceptions)>0][ii], "*  "))
#   exceptions[lengths(exceptions)>0][ii]
# 
# }



```

## Indicatior weights

```{r}
#-----------------------------------------------------
# PLOT WEIGHTS --------------------------------------------------
#-----------------------------------------------------

plot <- ggplot() +
  geom_boxplot(data = just.one.df, aes(x = sheet_name, y = weight), 
               width=0.3, color="grey70", fill = "white", alpha=0.2) +
  geom_point(data = just.one.df, 
             position = position_jitter(width = 0.2, height = 0),
             size = 1, shape = 16,
             aes(x = sheet_name, y = weight, color = respondant_name,
                 text = map(
                   paste0("<b>", `respondant_name`, "</b><br>",
                          "<b>Weight: </b>", weight, " (certainty ", cert_weight,")<br>"),
                   HTML))) +
  stat_summary(data = just.one.df, aes(x = sheet_name, y = weight,
                                       text = map(
                                         paste0("Mean weight"),
                                         HTML)),
               geom = "point", fun = mean,
               color = "red", shape = 3, size = 2,
               position = position_nudge(x = 0.05, y = 0)
               ) +
  labs(x = NULL, y = "Relative importance (weight)", 
       title = "Indicator weights",
       color = "Respondant") +
  theme_pubr()+
  theme(plot.title = element_text(size = 12),
        plot.subtitle = element_text(size = 12),
        legend.title = element_text(size = 12 , face = "bold"),
        legend.text =  element_text(size = 12),
        axis.text.x = element_text(angle = -60, hjust = 0, size = 10),
        axis.text.y = element_text(size = 12),
        axis.title =  element_text(size = 12),
        legend.position = "right",
        plot.margin = margin(0.5, 1, 0.5, 1, "cm")
  ) 
ggplotly(plot, tooltip = "text", dynamicTicks = F) %>% 
  config(displayModeBar = F) %>% 
  layout(yaxis = list(range = c(-5, 105)))
```


## Certainties



# Discussion points
- [ ] - Some value functions have a minimum score >0. Strictly speaking this is okay... but it does meant that the final condition score will not be on a 0-100 scale (there will always be some minimum condition score).








