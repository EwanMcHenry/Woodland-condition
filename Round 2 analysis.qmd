---
title: "Round 2 analysis"
author: "Ewan McHenry"
---

```{r setup}
library(tidyverse)
source("Scripts\\functions_delphi_analysis.R") 

r1_data <- prepare_round_data(1, "Data\\Delphi round 1\\", "response sheets\\", run_extraction = T)
r2_data <- prepare_round_data(2, "Data\\Delphi round 2\\", "response sheets\\", run_extraction = T)

all.respondents <- unique(c(r1_data$df$respondant_name, r2_data$df$respondant_name))
all.indicators <- unique(c(r1_data$df$indicator_name, r2_data$df$indicator_name))
```

```{r respondent_completion_table}
# table of respondents by round
respondent_table <- tibble(
  respondent_names = all.respondents,
  round1 = as.integer(all.respondents %in% r1_data$completed_summary$respondent_names),
  round2 = as.integer(all.respondents %in% r2_data$completed_summary$respondent_names)
)

respondent_table

```

```{r combine_rounds}
combine_rounds <- function(r1, r2, round1 = 1, round2 = 2) {
  bind_rows(
    mutate(r1, round = round1),
    mutate(r2, round = round2)
  )
}

c.df <- combine_rounds(r1_data$df, r2_data$df) %>% 
  arrange(respondant_name,indicator_num, round, measure)
c.completed_summary <- combine_rounds(r1_data$completed_summary, r2_data$completed_summary)
c.ind.matcher.df <- combine_rounds(r1_data$ind_matcher_df, r2_data$ind_matcher_df)
c.has_completed <- combine_rounds(r1_data$has_completed, r2_data$has_completed)
c.just.one.df <- combine_rounds(r1_data$just_one_df, r2_data$just_one_df)

```

```{r reduced_df}
red.df <- c.df %>% 
  arrange(respondant_name,indicator_num, round, measure) %>% 
  # select only the columns we want to see
  select(respondant_name, sheet_name, measure, value, round)


```

Looked at which respondent-indicator pairs hadn't differed between rounds. Happy now that data only contains forms that were actually completed by respondents.

```{r}
# find respondent name - indicator pairs that are identical between rounds
bk = 1
same_last = data.frame(respondent = NA, indicator = NA)

for (r in all.respondents) {
  for(i in all.indicators) {
      r1v <- c.df$value[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 1]
      r2v <- c.df$value[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 2]
      r1m <- c.df$measure[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 1]
      r2m <- c.df$measure[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 2]

        if ( # responses unchanged between round 1 and 2
          identical(r1v, r2v) & identical(r1m, r2m)) {
          same_last[bk,] = c(r, i)
          bk = bk + 1
    }
  }
}
same_last
```

Looked like some folk used different number of tree age categories. Table of max number of tree age categories used by respondent and round. Found in round 1 DK, NRB and PA had 5,5 and 3 categories respectively. Went into forms and altered. Intent seemed clear in all cases.

```{r}
# find max number of tree age categories used by respondent and round
nages <- c.df %>%
  filter(sheet_name == "Tree age distribution") %>%
  group_by(round, respondant_name) %>%
  summarise(
    max_age_categories = max(measure, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  filter (max_age_categories != 4)

```

```{r interpolation_of_vfs}
# note dependency on sheet_name
interpolation_measurements <- list(
  "Tree age distribution" = unique(c.df$measure[c.df$sheet_name == "Tree age distribution"]) %>% sort(),
  "Native canopy percentage " = seq(from = 0, to = 100, by = 1),
  "Vertical structure" = unique(c.df$measure[c.df$sheet_name == "Vertical structure"]) %>% sort(),
  "N tree & shrub spp." = seq(from = 0, to = 100, by = 1),
  "Invasive plants % cover" = seq(from = 0, to = 100, by = 1),
  "Deadwood" = 0:12,
  "Veteran trees" = seq(from = 0, to = 12, by = 0.5),
  "Woodland extent" = seq(from = 0, to = 100, by = 1),
  "Regen" = 0:3,
  "Herbivore damage" = 0:4,
  "Tree health" = seq(from = 0, to = 100, by = 1),
  "Ground flora" = seq(from = 0, to = 100, by = 1),
  "Horizontal complexity" = 0:5,
  "Anthropogenic damage" = seq(from = 0, to = 100, by = 1)
)

#create list : sheet_name -> round -> respondent ->  df( measurement and interpolated values), certainties and weights

interpolated.data <- list()
for (i in unique(c.df$sheet_name)) {
  interpolated.data[[i]] <- list()
  for (r in unique(c.df$round)) {
    interpolated.data[[i]][[r]] <- list()
    for (resp in unique(c.df$respondant_name)) {
      explanitory <- c.df$measure[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      response <- c.df$value[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      
      
      # Check conditions for adding value_function
      if (sum(!is.na(response))>1 && length(response) > 1 && diff(range(response, na.rm = TRUE)) > 0) {
        interpolated.data[[i]][[r]][[resp]] <- list(
          value_function = data.frame("measurement" = interpolation_measurements[[i]]),
          og_vf = data.frame("measurement" = explanitory, "value" = response),
          weight = c.df$weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          vf_cert = c.df$cert_val_funct[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          wt_cert = c.df$cert_weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          round = r,
          respondent = resp,
          indicator = i
          
        )
      } else {
        interpolated.data[[i]][[r]][[resp]] <- list(
          weight = c.df$weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          vf_cert = c.df$cert_val_funct[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          wt_cert = c.df$cert_weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1]
        )
      }
      

      } # resp
    }# round
  } # indicator

# use data from corresponding round, respondent and indicator to interpolate values

# i <- unique(c.df$sheet_name)[1]
# r <- unique(c.df$round)[1]
# resp <- unique(c.df$respondant_name)[1]
i <- "Horizontal complexity"
r <- 1
resp <- "Martin Hu"


library(mgcv)
for (i in unique(c.df$sheet_name)) {
  for (r in unique(c.df$round)) {
    for (resp in unique(c.df$respondant_name)) {
      # Check if value_function exists for the current combination
      if (!is.null(interpolated.data[[i]][[r]][[resp]]$value_function)) {

      #measurements for interpolation
      meas <- interpolated.data[[i]][[r]][[resp]]$value_function$measurement
      # data from form
      explanatory <- c.df$measure[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      response <- c.df$value[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      
      if(!identical(range(response), c(0,100))) {
        print(paste("Warning: response range not 0-100 for", i, r, resp))}

      # Create a data frame for modeling
      response_scaled <- (response - min(response)) / (max(response) - min(response))
      data <- data.frame(explanatory = explanatory, response_scaled = response_scaled)
      
      
      # Fit models
      ## binomial gam
      binom.spline_model <- gam(response_scaled ~ s(explanatory, bs = "cs", k = length(explanatory) - 1), 
                    family = binomial(link = "logit"), 
                    data = data, 
                    method = "REML")
      beta.spline_model <- gam(response_scaled ~ s(explanatory, bs = "cs", k = length(explanatory) - 1), 
                    family = betar(link = "logit"), 
                    data = data, 
                    method = "REML")
      ## beta gam
      linear.mod = lm(response ~ explanatory, data = data)
      
      AIC(linear.mod, binom.spline_model, beta.spline_model)

      
      
      # Predict over the interpolation measurements using best model, based on AIC
      if (AIC(linear.mod) == min(AIC(linear.mod, binom.spline_model, beta.spline_model))) {
        predictions_scaled <- predict(linear.mod, newdata = data.frame(explanatory = meas))
      } else if (AIC(binom.spline_model) == min(AIC(linear.mod, binom.spline_model, beta.spline_model))) {
        predictions_scaled <- predict(binom.spline_model, newdata = data.frame(explanatory = meas), type = "response")
      } else {
        predictions_scaled <- predict(beta.spline_model, newdata = data.frame(explanatory = meas), type = "response")
      }

      # fix to 0-100 bounds
      predictions_fixed <- (predictions_scaled - min(predictions_scaled))*(100/(max(predictions_scaled) - min(predictions_scaled)))
      
            if(!identical(range(predictions_fixed), c(0,100))) {
        print(paste("Warning: INTERPOLATED response range not 0-100 for", i, r, resp))}
      
            # add to interpolated.data
      interpolated.data[[i]][[r]][[resp]]$value_function$value <- predictions_fixed
      }
    }
  }
}

```

```{r bootstrap_predictions}

set.seed(5448)
boot_results <- list(indicator = list(NA))

boot_results <- list()

for (i in unique(c.df$sheet_name)) {
    boot_results[[i]] <- list()  
  for (r in unique(c.df$round)) {
    if(paste0(i,r) != "Herbivore damage1" ){
          resp_list <- NA
    bk = 1
    for (resp.n in 1:length(names(interpolated.data[[i]][[r]]))){
      response <- c.df$value[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      if(length(response)>2){
        resp_list[bk] <- names(interpolated.data[[i]][[r]])[resp.n]
        bk = bk + 1
      }
    }
    
    boot_expl <- interpolated.data[[i]][[r]][[resp_list[1]]]$value_function$measurement
    
    # sample by respondent
    boot_resps <- sample(resp_list, 1000, replace = TRUE)
    boot_res_pre = data.frame(expl = numeric(length(boot_expl)),
                              median = numeric(length(boot_expl)),
                              mean = numeric(length(boot_expl)),
                              upper95 = numeric(length(boot_expl)),
                              lower95 = numeric(length(boot_expl)))
        for(e in 1:length(boot_expl)){
          y = map(boot_resps, ~ interpolated.data[[i]][[r]][[.x]]$value_function$value[e]) %>%
    flatten_dbl()
          
          boot_res_pre$expl[e] <- boot_expl[e]
          boot_res_pre$median[e] <- median(y)
          boot_res_pre$mean[e] <- mean(y)
          boot_res_pre$upper95[e] <- quantile(y, 0.975)
          boot_res_pre$lower95[e] <- quantile(y, 0.025)
        }
    
        boot_results[[i]][[r]] <- list(indicator = i,             # Indicator name
                                   round = r,                 # Round number
                                   respondents = resp_list, # Vector of respondent names
                                   boot_response = data.frame( # Data frame with explanatory and response data
                                     expl = boot_res_pre$expl,
                                     median = boot_res_pre$median,
                                     mean = boot_res_pre$mean,
                                     upper95 = boot_res_pre$upper95,
                                     lower95 = boot_res_pre$lower95
                                   )
      )
    }
  }
}




```
```{r plots}



library(ggpubr)
library(grid)
library(gridExtra)
library(patchwork)

# Loop through each indicator
for (indicator in names(boot_results)) {
  # Initialize an empty list to hold plots for the rounds
  round_plots <- list()
  
  # Loop through each round for the current indicator
  for (round in seq_along(boot_results[[indicator]])) {
    round_data <- boot_results[[indicator]][[round]]
    
    if (is.null(round_data$boot_response) || round_data$indicator == "Herbivore Impact" && round == 1) {
      # Create an empty plot for "Herbivore Impact" round 1 or if data is NULL
      plot <- ggplot() +
        theme_void() +
        ggtitle(paste(indicator, "Round", round, "(No Data)"))
    } else {
      # Extract the boot_response data frame
      plot_data <- round_data$boot_response
      
      # Create the ggplot
      plot <- ggplot(plot_data, aes(x = expl, y = median)) +
        geom_line(color = "black", linewidth = 2) +
        geom_ribbon(aes(ymin = lower95, ymax = upper95), alpha = 0.2, fill = "grey13") +
        labs(
          title = paste("Round", round, "N =", length(round_data$respondents)),
          x = ind.matcher.df$ind.axis.title[ind.matcher.df$sheet_name == indicator],
          y = "Value"
        ) +
        theme_pubr()
    }
    
    # Append the plot to the round_plots list
    round_plots[[round]] <- plot
  }
    # Add a shared title
  shared_title <- textGrob(label = paste(indicator),
                           gp = gpar(fontsize = 16, fontface = "bold")
  )
  combined_plot <- grid.arrange(shared_title, grid_plots, heights = c(0.1, 0.9), nrow = 2)

  # Combine the two plots using patchwork
  ncol <- 2
  nrow <- ceiling(length(round_plots) / ncol)
  grid_plots <- arrangeGrob(grobs = round_plots, ncol = ncol)
  
  # Add a shared title
  shared_title <- textGrob(
    label = paste("Indicator:", indicator),
    gp = gpar(fontsize = 16, fontface = "bold")
  )
  combined_plot <- grid.arrange(shared_title, grid_plots, heights = c(0.1, 0.9), nrow = 2)

  # Save the plot (optional)
  ggsave(
    filename = paste0("plots/", indicator, "_round_plots.png"),
    plot = combined_plot,
    width = 10, height = 5
  )
  
  # Print the combined plot for this indicator
  print(combined_plot)
}


```

# Plots of respondent value functions

Coloured by respondent

```{r}

# using continuous_vf_fig() function, 

respondant_colours <-  set_resp_col_fun(unique(c.df$respondant_name))

# Loop through each indicator
for (indicator in names(boot_results)) {
  # Initialize an empty list to hold plots for the rounds
  round_plots <- list()
  
  # Loop through each round for the current indicator
  for (round in seq_along(boot_results[[indicator]])) {
    round_data <- boot_results[[indicator]][[round]]
    
    if (is.null(round_data$boot_response) || 
        (round_data$indicator == "Herbivore Impact" && round == 1)) {
      # Create an empty plot for "Herbivore Impact" round 1 or if data is NULL
      plot <- ggplot() +
        theme_void() +
        ggtitle(paste(indicator, "Round", round, "(No Data)"))
    } else {
      # Extract the boot_response data frame
      plot_data <- round_data$boot_response
      
      # Create a data frame for respondent-specific value functions
      respondent_data <- do.call(rbind, lapply(round_data$respondents, function(resp) {
        data.frame(
          expl = interpolated.data[[indicator]][[round]][[resp]]$value_function$measurement,
          value = interpolated.data[[indicator]][[round]][[resp]]$value_function$value,
          respondent = resp
        )
      }))
      
      # Create the ggplot
      plot <- ggplot() +
        # Add respondent-specific lines
        geom_line(data = respondent_data, 
                  aes(x = expl, y = value, color = respondent), 
                  alpha = 0.7, linewidth = 1) +
        # Add median and 95% CI ribbon
        geom_line(data = plot_data, aes(x = expl, y = median), color = "black", linewidth = 2) +
        geom_ribbon(data = plot_data, aes(x = expl, ymin = lower95, ymax = upper95), 
                    alpha = 0.2, fill = "grey13") +
        scale_color_manual(values = respondant_colours) +
        labs(
          title = paste("Round", round, "N =", length(round_data$respondents)),
          x = ind.matcher.df$ind.axis.title[ind.matcher.df$sheet_name == indicator],
          y = "Value",
          color = "Respondents"
        ) +
        theme_pubr()
    }
    
    # Append the plot to the round_plots list
    round_plots[[round]] <- plot
  }
  
  # Add a shared title
  shared_title <- textGrob(
    label = paste("Indicator:", indicator),
    gp = gpar(fontsize = 16, fontface = "bold")
  )
  
  # Combine plots using gridExtra
  ncol <- 2
  nrow <- ceiling(length(round_plots) / ncol)
  grid_plots <- arrangeGrob(grobs = round_plots, ncol = ncol)
  combined_plot <- grid.arrange(shared_title, grid_plots, heights = c(0.1, 0.9), nrow = 2)
  
  # Save the plot (optional)
  ggsave(
    filename = paste0("plots/", indicator, "_round_plots.png"),
    plot = combined_plot,
    width = 10, height = 5
  )
  
  # Print the combined plot for this indicator
  print(combined_plot)
}


```