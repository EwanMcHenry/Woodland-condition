---
title: "Round 2 analysis"
author: "Ewan McHenry"
---

```{r setup}
library(tidyverse)
source("Scripts\\functions_delphi_analysis.R") 

r1_data <- prepare_round_data(1, "Data\\Delphi round 1\\", "response sheets\\", run_extraction = T)
r2_data <- prepare_round_data(2, "Data\\Delphi round 2\\", "response sheets\\", run_extraction = T)

all.respondents <- unique(c(r1_data$df$respondant_name, r2_data$df$respondant_name))
all.indicators <- unique(c(r1_data$df$indicator_name, r2_data$df$indicator_name))
```

```{r respondent-completion-table}
# table of respondents by round
respondent_table <- tibble(
  respondent_names = all.respondents,
  round1 = as.integer(all.respondents %in% r1_data$completed_summary$respondent_names),
  round2 = as.integer(all.respondents %in% r2_data$completed_summary$respondent_names)
)

respondent_table

```

```{r combine_rounds}
combine_rounds <- function(r1, r2, round1 = 1, round2 = 2) {
  bind_rows(
    mutate(r1, round = round1),
    mutate(r2, round = round2)
  )
}

c.df <- combine_rounds(r1_data$df, r2_data$df) %>% 
  arrange(respondant_name,indicator_num, round, measure)
c.completed_summary <- combine_rounds(r1_data$completed_summary, r2_data$completed_summary)
c.ind.matcher.df <- combine_rounds(r1_data$ind_matcher_df, r2_data$ind_matcher_df)
c.has_completed <- combine_rounds(r1_data$has_completed, r2_data$has_completed)
c.just.one.df <- combine_rounds(r1_data$just_one_df, r2_data$just_one_df)

```

```{r reduced df}
red.df <- c.df %>% 
  arrange(respondant_name,indicator_num, round, measure) %>% 
  # select only the columns we want to see
  select(respondant_name, sheet_name, measure, value, round)


```

Looked at which respondent-indicator pairs hadn't differed between rounds. Happy now that data only contains forms that were actually completed by respondents.

```{r}
# find respondent name - indicator pairs that are identical between rounds
bk = 1
same_last = data.frame(respondent = NA, indicator = NA)

for (r in all.respondents) {
  for(i in all.indicators) {
      r1v <- c.df$value[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 1]
      r2v <- c.df$value[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 2]
      r1m <- c.df$measure[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 1]
      r2m <- c.df$measure[c.df$respondant_name == r & c.df$indicator_name == i & c.df$round == 2]

        if ( # responses unchanged between round 1 and 2
          identical(r1v, r2v) & identical(r1m, r2m)) {
          same_last[bk,] = c(r, i)
          bk = bk + 1
    }
  }
}
same_last
```

Looked like some folk used different number of tree age categories. Table of max number of tree age categories used by respondent and round. Found in round 1 DK, NRB and PA had 5,5 and 3 categories respectively. Went into forms and altered. Intent seemed clear in all cases.

```{r}
# find max number of tree age categories used by respondent and round
nages <- c.df %>%
  filter(sheet_name == "Tree age distribution") %>%
  group_by(round, respondant_name) %>%
  summarise(
    max_age_categories = max(measure, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  filter (max_age_categories != 4)

```

```{r interpolation of vfs}
# note dependency on sheet_name
interpolation_measurements <- list(
  "Tree age distribution" = unique(c.df$measure[c.df$sheet_name == "Tree age distribution"]) %>% sort(),
  "Native canopy percentage " = seq(from = 0, to = 100, by = 5),
  "Vertical structure" = unique(c.df$measure[c.df$sheet_name == "Vertical structure"]) %>% sort(),
  "N tree & shrub spp." = seq(from = 0, to = 100, by = 5),
  "Invasive plants % cover" = seq(from = 0, to = 100, by = 5),
  "Deadwood" = 0:12,
  "Veteran trees" = seq(from = 0, to = 12, by = 0.5),
  "Woodland extent" = seq(from = 0, to = 100, by = 1),
  "Regen" = 0:3,
  "Herbivore damage" = 0:4,
  "Tree health" = seq(from = 0, to = 100, by = 5),
  "Ground flora" = seq(from = 0, to = 100, by = 5),
  "Horizontal complexity" = 0:5,
  "Anthropogenic damage" = seq(from = 0, to = 100, by = 5)
)

#create list : sheet_name -> round -> respondent ->  df( measurement and interpolated values), certainties and weights

interpolated.data <- list()
for (i in unique(c.df$sheet_name)) {
  interpolated.data[[i]] <- list()
  for (r in unique(c.df$round)) {
    interpolated.data[[i]][[r]] <- list()
    for (resp in unique(c.df$respondant_name)) {
      explanitory <- c.df$measure[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      response <- c.df$value[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      
      
      # Check conditions for adding value_function
      if (sum(!is.na(response))>1 && length(response) > 1 && diff(range(response, na.rm = TRUE)) > 0) {
        interpolated.data[[i]][[r]][[resp]] <- list(
          value_function = data.frame("measurement" = interpolation_measurements[[i]]),
          weight = c.df$weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          vf_cert = c.df$cert_val_funct[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          wt_cert = c.df$cert_weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1]
        )
      } else {
        interpolated.data[[i]][[r]][[resp]] <- list(
          weight = c.df$weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          vf_cert = c.df$cert_val_funct[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1],
          wt_cert = c.df$cert_weight[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp][1]
        )
      }
      

      } # resp
    }# round
  } # indicator

# use data from corresponding round, respondent and indicator to interpolate values

# i <- unique(c.df$sheet_name)[1]
# r <- unique(c.df$round)[1]
# resp <- unique(c.df$respondant_name)[1]
i <- "Native canopy percentage "
r <- 1
resp <- "Paul Allen"


library(mgcv)
for (i in unique(c.df$sheet_name)) {
  for (r in unique(c.df$round)) {
    for (resp in unique(c.df$respondant_name)) {
      # Check if value_function exists for the current combination
      if (!is.null(interpolated.data[[i]][[r]][[resp]]$value_function)) {

      #measurements for interpolation
      meas <- interpolated.data[[i]][[r]][[resp]]$value_function$measurement
      # data from form
      explanatory <- c.df$measure[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      response <- c.df$value[c.df$sheet_name == i & c.df$round == r & c.df$respondant_name == resp]
      
      if(!identical(range(response), c(0,100))) {
        print(paste("Warning: response range not 0-100 for", i, r, resp))}

      # Create a data frame for modeling
      response_scaled <- (response - min(response)) / (max(response) - min(response))
      data <- data.frame(explanatory = explanatory, response_scaled = response_scaled)
      # Fit a GAM
      spline_model <- gam(response_scaled ~ s(explanatory, bs = "cs", k = length(explanatory) - 1), 
                    family = binomial(link = "logit"), 
                    data = data, 
                    method = "REML")
      # Predict over the interpolation measurements
      predictions_scaled <- predict(spline_model, newdata = data.frame(explanatory = meas), type = "response")
      # fix to 0-100 bounds
      predictions_fixed <- (predictions_scaled - min(predictions_scaled))*(100/(max(predictions_scaled) - min(predictions_scaled)))
      
            if(!identical(range(predictions_fixed), c(0,100))) {
        print(paste("Warning: INTERPOLATED response range not 0-100 for", i, r, resp))}
      
            # add to interpolated.data
      interpolated.data[[i]][[r]][[resp]]$value_function$value <- predictions_fixed
      }
    }
  }
}

```

# Plots of each indicator value functions, with different respondents in different colours


```{r}
respondant_colours <-  set_resp_col_fun(unique(c.df$respondant_name))

# using continuous_vf_fig() function, 

i <- "Native canopy percentage "
r <- 1

library(ggpubr)
library(plotly)
library(htmltools)
library(patchwork)

plot_list <- list()

for (i in unique(c.df$sheet_name)) {
  for (r in unique(c.df$round)) {
    # create df of all data for this round and indicator
    filtered_data <- data.frame()
    for(resp in unique(c.df$respondant_name)) {
      if (!is.null(interpolated.data[[i]][[r]][[resp]]$value_function)) {
        filtered_data <- rbind(filtered_data, 
                               data.frame(
                                 measure = interpolated.data[[i]][[r]][[resp]]$value_function$measurement,
                                 value = interpolated.data[[i]][[r]][[resp]]$value_function$value,
                                 respondant_name = resp,
                                 cert_val_funct = interpolated.data[[i]][[r]][[resp]]$vf_cert %>% as.numeric()
                                 
                                 )
        )
      }
    }
    filtered_data$value.dec <- filtered_data$value/100
    
    filtered_data$cert_val_funct[is.na(filtered_data$cert_val_funct)] <- 3 # HACK!!!!!!

    
ind.num = which(ind.matcher.df$sheet_name == i )
indicator_name = ind.matcher.df$indicator_name[ind.num]
ind.axis.title <- ind.matcher.df$ind.axis.title[ind.num]
    
    # p <- continuous_vf_fig(line.col = "black", 
    #                        filtered_data = filtered_data, 
    #                        respondant_colours = respondant_colours) 
    # 
    # 
    # print(p)

    plot <- ggplot_gam_resp_vf(indicator_name, 
                               gam.col = "black", 
                               x.lab = ind.axis.title, 
                               pal = respondant_colours,
                               filtered_data = filtered_data)

    # Store the plot in the list, using indicator and round as identifiers
    plot_list[[paste(i, r, sep = "_")]] <- plot

  }}
    


# Combine the plots for each indicator and round (1 and 2) into a 1x2 grid using patchwork
combined_plots <- list()

for (i in unique(c.df$sheet_name)) {
  # Create the 1x2 layout for this indicator
  indicator_plots <- plot_list[[paste(i, 1, sep = "_")]] + plot_list[[paste(i, 2, sep = "_")]] + plot_layout(ncol = 2)
  combined_plots[[i]] <- indicator_plots
}

# To view the plots, you can print the individual indicator plots
combined_plots[[1]]  # Example: print the first indicator plot