---
title: "WECA Casestudy - Ladypark Wood"
author: "Ewan McHenry"

format:
  html:
    self-contained: true
    embed-resources: true
    theme: cosmo
    code-fold: true       # Enables folding
    code-summary: "Show code"  # Optional: custom label on the fold button
    toc: true              # Optional: adds a table of contents
    toc-depth: 2
    toc-float: true       # Optional: makes the table of contents float on the page
---
```{=html}
<script>
  function toggleVisibility(id) {
    const el = document.getElementById(id);
    if (el.style.display === "none") {
      el.style.display = "block";
    } else {
      el.style.display = "none";
    }
  }
</script>
```
```{r libraries and scripts, warning=F, message=F}

# LIBRARIES ---------------------------------------------------------------
library(tidyverse)
library(knitr)
library(kableExtra)
library(DT)
library(htmltools)
library(ggpubr)
library(U.utilities)
library(fuzzyjoin)
library(tidyselect)

source("function-extract plot data.R")

appropriate_tree_path <- "Data\\Appropriate_tree_spp_list.csv"
appropriate_flora_path <- "Data\\Appropriate_groundflora_spp_list.csv"
high_threat_invasives_path <- "Data\\high_threat_invasives_list.csv"

microhabitats_list <- read.csv("Data\\microhabitats_list.csv")

# Load the lookup tables
age_lookup <- read.csv("outputs\\lookup_tables\\Tree age distribution_vf_lookup.csv")
tree_spp_lookup <- read.csv("outputs\\lookup_tables\\N tree & shrub spp._vf_lookup.csv")
antropogenic_damage_lookup <- read.csv("outputs\\lookup_tables\\Anthropogenic damage_vf_lookup_domin.csv")
deadwood_lookup <- read.csv("outputs\\lookup_tables\\Deadwood_vf_lookup.csv")
ground_flora_lookup <- read.csv("outputs\\lookup_tables\\Ground flora_vf_lookup.csv")
Herbivore_impact_lookup <- read.csv("outputs\\lookup_tables\\Herbivore damage_vf_lookup.csv")
Horizontal_complexity_lookup <- read.csv("outputs\\lookup_tables\\Horizontal complexity_vf_lookup.csv")
invasives_lookup <- read.csv("outputs\\lookup_tables\\Invasive plants % cover_vf_lookup_domin.csv")
microhabitats_lookup <- read.csv("outputs\\lookup_tables\\Microhabitats_vf_lookup.csv")
native_canopy_lookup <- read.csv("outputs\\lookup_tables\\Native canopy percentage _vf_lookup.csv")
regen_lookup <- read.csv("outputs\\lookup_tables\\Regen_vf_lookup.csv")
tree_health_lookup <- read.csv("outputs\\lookup_tables\\Tree health_vf_lookup.csv")
vertical_structure_lookup <- read.csv("outputs\\lookup_tables\\Vertical structure_vf_lookup.csv")
veteran_trees_lookup <- read.csv("outputs\\lookup_tables\\Veteran trees_vf_lookup.csv")

weights_lookup <- read.csv("outputs\\lookup_tables\\weights_lookup.csv")

#load domin range table
domin_transformer <- read.csv("Data\\domin transformer.csv") %>% 
  mutate(domin = as.character(antropogenic_damage_lookup$domin))
domin_transformer$mid = domin_transformer$min + (domin_transformer$max - domin_transformer$min) / 2

# load value function predictions
load("outputs\\all_value_functions.RData")
```
```{r configuration, echo=FALSE}

vert_structure_categories <- data.frame(
  index = 1:6,
  strata = c("Ground layer (0 - 0.1m)",
             "Field layer (0.1 - 1m)",
             "Shrub (1 - 5m)",
             "Lower (5 -12m)",
             "Middle (12 -20m)",
             "Upper (20m+)")
  )


vf_alpha = 0.6
```

This doc walks through the calculation of WECA score for each indicator at each plot, and zone level, focusing on Ladypark Wood.

I have written a [function](D:/Users/Ewan%20McHenry/OneDrive%20-%20the%20Woodland%20Trust/WEC/Woodland-condition/function-extract%20plot%20data.R) that extracts the WECA survey info from the [field survey form](%22D:\Users\Ewan%20McHenry\OneDrive%20-%20the%20Woodland%20Trust\WEC\Woodland-condition\Data\Field%20Test\Ladypark%20Wood,%20Wye%20valley%20-%20Non-intervention%2070yrs%20broadleaf%20SSSI%20ASNW\WCA%20-%20Lady%20park%20wood%20-%20Field%20test%20-%2012.06.2025.xlsx%22) and converts it to the point prior to comparison with the value function lookup tables and weightings that were produced in [Estimating value functions and weightings - Delphi Round 2 analysis](D:/Users/Ewan%20McHenry/OneDrive%20-%20the%20Woodland%20Trust/WEC/Woodland-condition/Estimating%20value%20functions%20and%20weightings%20-%20Delphi%20Round%202%20analysis.qmd).

```{r extract_survey_data, message=F, warning=FALSE}
survey_data <- extract_plot_survey_data(
  excel_sheet_folderpath = "Data\\Field Test\\Ladypark Wood, Wye valley - Non-intervention 70yrs broadleaf SSSI ASNW\\",
  excel_sheet_filename = "WCA - Lady park wood - Field test - 12.06.2025.xlsx",
  sheet_appropriate_ground_flora = read.csv(appropriate_flora_path),
  sheet_appropriate_tree_spp = read.csv(appropriate_tree_path) ,
  list_high_threat_invasives = read.csv(high_threat_invasives_path)$species, # list of high threat invasive species, used to check if any are present in the plot data
  habiat_type = "base_rich_lowland"

  )
```

## Tree info

At each plot and supplementary plot info was gathered on tree and shrub species present, the number in each age class and the cover of seedlings and saplings. This info is used to calulate multiple indicators, including the number of tree species, the number of age classes, the number of native species and the cover of seedlings and saplings.

The survey data can be explored below

```{r tree_info, results='asis'}

outputs <- list()

for (i in seq_along(survey_data)) {
  section_outputs <- list()

  for (df_name in c("trees_main_df", "trees_supp_df")) {
    df <- survey_data[[i]]$trees_df[[df_name]] %>%
      mutate(across(c(seedlings, saplings), as.character))

    totals <- df %>%
      summarise(across(c(young, semi_mature, early_mature, mature, spp_total_trees), ~ sum(.x, na.rm = TRUE))) %>%
      mutate(tree_species = "Total", seedlings = "", saplings = "") %>%
      select(names(df))

    df_total <- bind_rows(df, totals)

    section_outputs[[df_name]] <- datatable(
      df_total,
      caption = paste0("Tree Data - ", ifelse(df_name == "trees_main_df", "Main", "Supplementary")),
      rownames = FALSE,
      options = list(
        pageLength = nrow(df_total),
        dom = 't',
        ordering = FALSE
      )
    )
  }

  # Wrap in a <details> HTML element with <summary> title
plot_section <- tags$details(
  tags$summary(paste("Plot", i)),

  tags$details(
    tags$summary(style = "margin-left: 1em;", "Main Plot"),
    section_outputs$trees_main_df
  ),

  tags$details(
    tags$summary(style = "margin-left: 1em;", "Supplementary Plot"),
    section_outputs$trees_supp_df
  )
)

  outputs[[i]] <- plot_section
}

# Render all collapsible plot sections
tagList(outputs)
```


## Tree age structure

```{r age_structure_scoring}

this.sheet <- "Tree Age distribution"
x.axis_title <- "Number of tree age classes"
age_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators
  tibble(
    plot = i,
    plot_type = c("main", "supp"),
    age_classes_n = c(ind$tree_age_classes$ind.age_classes_n.main, ind$tree_age_classes$ind.age_classes_n.supp),
    shannon = c(ind$tree_age_classes$ind.tree_age_classes_shannon.main, ind$tree_age_classes$ind.tree_age_classes_shannon.supp) %>% round(2),
  ) %>%
    bind_cols(
      bind_rows(ind$tree_age_classes$main_ages, ind$tree_age_classes$supp_ages)
    )
}) %>% 
  # add corresponding value from lookup table
  left_join(age_lookup, by = c("age_classes_n" = "N.Tree.Age.Categories")) %>% 
  #reorder
  select(plot, plot_type, value, age_classes_n, shannon, everything()) %>% 
  mutate(plottype = factor(plot_type, levels = c("main", "supp")),
         plot = factor(plot)) %>%
  rename()




```

The mean age structure value across the zone is `r round(mean(age_summary$value, na.rm = TRUE), 2)`.

Age structure value is a function of the number of different age classes present in each plot and is presented in the table below.

A Shannon diversity index could be an alternative measure with which to infer value, it considers the the number of trees in each age class and the degree to which age classes might dominate.

```{r age_structure_table, results='asis'}

datatable(
  age_summary %>% 
    mutate(
      value = round(value, 2),
      shannon = round(shannon, 2),
      plot = as.factor(plot),
      plot_type = as.factor(plot_type)
    ), 
  rownames = FALSE,
  caption = "Tree Age Class Summary by Plot and Subplot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r age_structure_plot, warnin=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = age_structure_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = age_summary,
    aes(
      x = age_classes_n,
      y = value,
      colour = plot,
      shape = plottype
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  scale_shape_manual(values = c(16, 18)) +
  # Axes and titles
  labs(
    x = x.axis_title,
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Tree species richness
```{r tree_species_richness_scoring}
this.sheet <- "Native tree and shrub species: proportion of appropraite present"
x.axis_title <- "Proportion of appropriate tree/shrub species present"

tree_species_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$tree_spp

  # Add plot and type columns to each tibble
  main <- ind$trees_main_spp_present %>%
    mutate(plot = i, plot_type = "main")
  
  supp <- ind$trees_supp_spp_present %>%
    mutate(plot = i, plot_type = "supp")

  # Combine and pivot wider (species as columns)
  bind_rows(main, supp) %>%
    pivot_wider(
      names_from = tree_species,
      values_from = spp_total_trees,
      values_fill = 0
    ) %>%
    left_join(
      tibble(
        plot = i,
        plot_type = c("main", "supp"),
        per_of_appropriate_species = c(ind$ind.tree_spp_prop_appropriate.main, ind$ind.tree_spp_prop_appropriate.supp)*100,
        N_appropriate_species = c(ind$ind.tree_spp_N_appropriate.main, ind$ind.tree_spp_N_appropriate.supp),
        spp_n = c(ind$ind.tree_spp_n.main, ind$ind.tree_spp_n.supp),
        shannon_index_appropriate = round(c(ind$ind.tree_spp_shannon_appropriate.main, ind$ind.tree_spp_shannon_appropriate.supp), 2)
      ),
      by = c("plot", "plot_type")
    )
})

# Closest match join using fuzzyjoin
tree_species_summary_matched <- tree_species_summary %>%
  fuzzyjoin::difference_inner_join(tree_spp_lookup,
    by = c("per_of_appropriate_species" = "Proportion.of.appropriate.Tree...Shrub.Species"),
    max_dist = Inf,
    distance_col = "dist"
  ) %>%
  group_by(plot, plot_type) %>%
  slice_min(order_by = dist, n = 1) %>%  # Keep only the closest match
  ungroup()  %>% 
  # replace nas with 0 for everything
  mutate(across(where(is.numeric), ~ replace_na(.x, 0))) %>%
  select(-dist, -Proportion.of.appropriate.Tree...Shrub.Species) %>%
  select(plot, plot_type, value, per_of_appropriate_species,N_appropriate_species, spp_n, shannon_index_appropriate, everything())  %>%
  relocate(
    # Move alphabetically sorted species columns to the end, after metadata
    sort(setdiff(names(.), c("plot", "plot_type", "value", "per_of_appropriate_species", "N_appropriate_species", "spp_n", "shannon_index_appropriate"))),
    .after = shannon_index_appropriate
  ) %>% 
  mutate(
    plot = factor(plot),
    plot_type = factor(plot_type, levels = c("main", "supp"))
  )

```

The mean tree species richness value across the zone is `r round(mean(tree_species_summary_matched$value, na.rm = TRUE), 2)`.

Tree species richness value is a function of the proportion of appropriate tree and shrub species found in each plot (appropriate species lists are habitat-specific).

A Shannon diversity index could be an alternative measure with which to infer value, it considers the number of trees in each species and the degree to which species might dominate.

The appropriate tree and shrub species list for this habitat type (`r survey_data[[i]]$survey_info$habiat_type`) has `r length(survey_data[[1]]$indicators$tree_spp$list_appropriate_tree_spp)` species in it, they are: `r paste(survey_data[[1]]$indicators$tree_spp$list_appropriate_tree_spp, collapse = ", ")`.

```{r tree_species_richness_table, results='asis'}
datatable(
  tree_species_summary_matched %>% 
    mutate(
      value = round(value, 2),
      shannon_index_appropriate = round(shannon_index_appropriate, 2),
      per_of_appropriate_species = paste(round(per_of_appropriate_species, 2), "%", sep = "")
    ) %>%
  rename(
    Plot = plot,
    'Plot type' = plot_type,
    Value = value,
    'Percent of appropriate species list present' = per_of_appropriate_species,
    'N species' = spp_n,
    'N species from appropriate species list ' = N_appropriate_species,
    'Shannon diversity of appropriate species' = shannon_index_appropriate
  ) ,
  rownames = FALSE,
  caption = "Tree Species Richness Summary by Plot and Subplot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r tree_species_richness_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = n_tree_shrub_spp_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = tree_species_summary_matched,
    aes(
      x = per_of_appropriate_species,
      y = value,
      colour = plot,
      shape = plot_type
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  scale_shape_manual(values = c(16, 18)) +
  # Axes and titles
  labs(
    x = "Percentage of appropriate species list present",
    y = "Value",
    title = paste(this.sheet),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Regen

```{r regen_scoring}
this.sheet <- "Tree & shrub regen"
x.axis_title <- "Number of regen classes present"
regen_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$regen
  
  main_classes_present <- ind$regen_species_classes.main %>%
    select(-tree_species) %>%
    colSums()>0
  
  supp_classes_present <- ind$regen_species_classes.supp %>%
    select(-tree_species) %>%
    colSums()>0
  
  # Add plot and type columns to each tibble
  main <- main_classes_present %>%
  tibble::enframe(name = "age_class", value = "present") %>%
  mutate(plot = i, plot_type = "main")
  
  supp <- supp_classes_present %>%
    tibble::enframe(name = "age_class", value = "present") %>%
    mutate(plot = i, plot_type = "supp")

  # Combine and pivot wider (species as columns)
  bind_rows(main, supp) %>%
    pivot_wider(
      names_from = age_class,      
      values_from = present,
      values_fill = FALSE         
  ) %>%
    left_join(
      tibble(
        plot = i,
        plot_type = c("main", "supp"),
        regen_classes_n = c(ind$ind.regen_classes_n.main, ind$ind.regen_classes_n.supp)
      ),
      by = c("plot", "plot_type")
    )
}) %>% 
  # join value
    left_join(regen_lookup, by = c("regen_classes_n" = "N.Regen.classes.present")) %>% 
  #reorder
  select(plot, plot_type, value, regen_classes_n, everything()) %>% 
  mutate(plottype = factor(plot_type, levels = c("main", "supp")),
         plot = factor(plot)) %>% 
  select(-plottype)



```

The mean regen value across the zone is `r round(mean(regen_summary$value, na.rm = TRUE), 2)`.

Regen value is a function of the number of regen classes of trees or shrubs present in each plot (seedlings, saplings and young trees).

```{r regen_table, results='asis'}
datatable(
  regen_summary %>% 
    mutate(
      value = round(value, 2),
      regen_classes_n = as.character(regen_classes_n)
    ) %>%
    rename(
      Plot = plot,
      'Plot type' = plot_type,
      Value = value,
      'Number of regen classes' = regen_classes_n
    ),
  rownames = FALSE,
  caption = "Regen Summary by Plot and Subplot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r regen_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = regen_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = regen_summary,
    aes(
      x = regen_classes_n,
      y = value,
      colour = plot,
      shape = plot_type
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  scale_shape_manual(values = c(16, 18)) +
  # Axes and titles
  labs(
    x = "Number of regen classes",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Native canopy cover
```{r native_canopy_cover_scoring}
this.sheet <- "Native canopy percentage"
x.axis_title <- "Canopy nativness (% of total canopy volume)"
native_canopy_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$canopy_nativness
  
  tibble(
    plot = i,
    native_canopy_cover = ind$ind.nativeness.measure
  )
}) %>% 
  # join value
  left_join(native_canopy_lookup, by = c("native_canopy_cover" = "Native.Canopy.Percentage")) %>% 
  #reorder
  select(plot, value, native_canopy_cover) %>% 
  mutate(plot = factor(plot)) 
```

The mean native canopy cover value across the zone is `r round(mean(native_canopy_summary$value, na.rm = TRUE), 2)`.

Native canopy cover value is a function of the proportion of each plots's total canopy volume made up of UK native tree and shrub species.

```{r native_canopy_cover_table, results='asis'}
datatable(
  native_canopy_summary %>% 
    mutate(
      value = round(value, 2),
      native_canopy_cover = paste(round(native_canopy_cover, 2), "%", sep = "")
    ) %>%
    rename(
      Plot = plot,
      Value = value,
      'Native canopy cover' = native_canopy_cover
    ),
  rownames = FALSE,
  caption = "Native Canopy Cover Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r native_canopy_cover_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = native_canopy_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = native_canopy_summary,
    aes(
      x = native_canopy_cover,
      y = value,
      colour = plot
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Native canopy cover (%)",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Vertical structure
```{r vertical_structure_scoring}
this.sheet <- "Vertical structure"
x.axis_title <- "Number of vertical strata present"
vertical_structure_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$vert_structure

  # Extract stratum cover as wide format
  cover_df <- ind$vert_structure %>%
    as_tibble() %>%
    # mutate(stratum = str_replace_all(stratum, " \\(.*\\)", ""),  # Remove ranges
    #        stratum = str_replace_all(stratum, "\\s+", "_")) %>%  # Replace spaces with underscores
    select(stratum, cover) %>%
    pivot_wider(names_from = stratum, values_from = cover)

  # Add plot number and count of strata
  cover_df %>%
    mutate(
      plot = i,
      vertical_structure_n = survey_data[[i]]$indicators$vert_structure$ind.vert_structure_n
    ) %>%
    select(plot, vertical_structure_n, everything())
}) %>% 
  # join value
  left_join(vertical_structure_lookup, by = c("vertical_structure_n" = "N.Vertical.Structure.Categories")) %>% 
  #reorder
  select(plot, value, vertical_structure_n, everything()) %>% 
  mutate(plot = factor(plot))
```

The mean vertical structure value across the zone is `r round(mean(vertical_structure_summary$value, na.rm = TRUE), 2)`.

Vertical structure value is a function of the number of different vertical strata present in each plot, where the cover of that strata is ecologically significant (> 10%).

```{r vertical_structure_table, results='asis'}
datatable(
  vertical_structure_summary %>% 
    mutate(
      value = round(value, 2),
      vertical_structure_n = as.character(vertical_structure_n)
    ) %>%
    rename(
      Plot = plot,
      Value = value,
      'Number of strata' = vertical_structure_n
    ),
  rownames = FALSE,
  caption = "Vertical Structure Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r vertical_structure_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = vertical_structure_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = vertical_structure_summary,
    aes(
      x = vertical_structure_n,
      y = value,
      colour = plot
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Number of vertical strata",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Invasive plants
```{r invasives_scoring}
this.sheet <- "Invasive plants"
x.axis_title <- "Total invasive cover (%)"
invasives_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$invasives
  
    # Handle the invasive_spp tibble (could be empty)
  inv_spp_wide <- ind$invasive_spp %>%
    # If empty, create empty tibble with columns for consistent pivoting
    { if (nrow(.) == 0) tibble(invasive_species = character(), cover = numeric()) else . } %>%
    mutate(invasive_species = str_replace_all(invasive_species, "\\s+", "_")) %>% # clean species names
    select(invasive_species, cover) %>%
    pivot_wider(names_from = invasive_species, values_from = cover, values_fill = 0)

  invasive_metadata <- tibble(
    plot = i,
    total_invasive_domin_cover = ind$ind.invasive.total_domin,
    high_threat_spp_present = ind$ind.invasive.high_threat_present
  )

if (ncol(inv_spp_wide) > 0) {
  result <- bind_cols(invasive_metadata, inv_spp_wide)
} else {
  result <- invasive_metadata
}
  
  result %>% 
    left_join(invasives_lookup, by = c("total_invasive_domin_cover" = "domin")) %>% 
    fuzzyjoin::difference_left_join(
      invasive_plants_predictions,
      by = "value",
      max_dist = Inf,
      distance_col = "dist"
    ) %>%
    # Keep only the closest match per plot
    group_by(plot) %>%  
    slice_min(order_by = dist, n = 1, with_ties = FALSE) %>% 
    ungroup()  %>%
    # Keep only one value column, here we keep value.x and drop value.y
    select(-value.y, -dist) %>%
    rename(value = value.x,
           dummy_measure = measure ) %>%
    # if high threat present, overwrite value with 0
    mutate(value = ifelse(high_threat_spp_present, 0, value)) %>%
    select(plot, value, total_invasive_domin_cover ,high_threat_spp_present , everything()) %>% 
    mutate(plot = factor(plot))
})
```

The mean invasives value across the zone is `r round(mean(invasives_summary$value, na.rm = TRUE), 2)`.

Invasives value is a function of the total cover of invasive species in each plot, overwritten with a zero value if any high threat invasive species are present.

```{r invasives_table, results='asis'}
datatable(
  invasives_summary %>% 
    mutate(
      value = round(value, 2),
      total_invasive_domin_cover = total_invasive_domin_cover,
      high_threat_spp_present = ifelse(high_threat_spp_present, "Yes", "No")
    ) %>%
    select(-dummy_measure) %>% # remove dummy measure column
    rename(
      Plot = plot,
      Value = value,
      'Total invasive cover' = total_invasive_domin_cover,
      'High threat species present' = high_threat_spp_present
    ),
  rownames = FALSE,
  caption = "Invasive Species Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r invasives_plot, warning=FALSE, message=FALSE}

ggplot() +
  geom_line(
    data = invasive_plants_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = invasives_summary,
    aes(
      x = dummy_measure,
      y = value,
      colour = plot
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Total invasive cover (%)",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Microhabitats
```{r microhabitats_scoring}
this.sheet <- "Microhabitats"
x.axis_title <- "Proportion of microhabitats present (%)"

# Microhabitats present list - cleaned unique
all_microhabitats <- survey_data %>%
  map(~ .x$indicators$microhabitats$microhabitats_present) %>%
  unlist() %>%
  str_replace_all("\\r\\n", " ") %>%
  str_squish() %>%
  unique() %>% 
  sort()

microhabitats_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$microhabitats
  
  # Clean current plot's microhabitats present
  present_clean <- str_replace_all(ind$microhabitats_present, "\\r\\n", " ") %>% str_squish()
  
  # Create a logical named vector of presence/absence for all microhabitats
  presence_logical <- setNames(all_microhabitats %in% present_clean, all_microhabitats)
  
  # Build summary tibble
  base_tbl <- tibble(
    plot = i,
    microhabitats_prop = 100 * ind$ind.microhabitats_n  / length(microhabitats_list$microhabitat_name),
    microhabitats_n = ind$ind.microhabitats_n
  ) %>%
  # Join fuzzy lookup as before
  fuzzyjoin::difference_left_join(
    microhabitats_lookup,
    by = c("microhabitats_prop" = "Proportion.of.microhabitats.present"),
    max_dist = Inf,
    distance_col = "dist"
  ) %>%
  group_by(plot) %>%
  slice_min(order_by = dist, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(-dist, -Proportion.of.microhabitats.present) %>%
  select(plot, value, microhabitats_prop, microhabitats_n, everything()) %>%
  mutate(plot = factor(plot))
  
  # Bind presence/absence columns
  bind_cols(base_tbl, as_tibble(t(presence_logical)))
})


```

The mean microhabitats value across the zone is `r round(mean(microhabitats_summary$value, na.rm = TRUE), 2)`.

Microhabitats value is a function of the proportion of all possible microhabitats present in each plot.

```{r microhabitats_table, results='asis'}
datatable(
  microhabitats_summary %>% 
    mutate(
      value = round(value, 2),
      microhabitats_prop = paste(round(microhabitats_prop, 2), "%", sep = ""),
      microhabitats_n = as.character(microhabitats_n)
    ) %>%
    rename(
      Plot = plot,
      Value = value,
      'Microhabitats present (%)' = microhabitats_prop,
      'Number of microhabitats' = microhabitats_n
    ),
  rownames = FALSE,
  caption = "Microhabitats Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r microhabitats_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = microhab_vf_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = microhabitats_summary,
    aes(
      x = microhabitats_prop,
      y = value,
      colour = plot
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Microhabitats present (%)",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Horizontal complexity
```{r horizontal_complexity_scoring}
this.sheet <- "Horizontal complexity"
horizontal_complexity_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$horizontal_complexity
  
  # N stops of each top hegith catgegory
  topheights_df <- vert_structure_categories %>%
  left_join(ind$top_heights_df %>% mutate(top_height = as.numeric(top_height)), 
            by = c("index" = "top_height")) %>%
  mutate(count = replace_na(count, 0)) %>%  # Replace missing counts with 0
  select(strata, count) %>%
  pivot_wider(names_from = strata, values_from = count)
  
  # summary table
  tibble(
    plot = i,
    N_topheight_cats = ind$ind.horizontal_complexity_n,
    shannon_topheight_cats = round(ind$ind.horizontal_complexity_shannon, 2)
  ) %>% 
      # add col for each top height and the count for each plot
  bind_cols(topheights_df %>% 
    mutate(across(everything(), as.numeric))  # Ensure all counts are numeric
  )
  }) %>% 
  # join value
  left_join(Horizontal_complexity_lookup, by = c("N_topheight_cats" = "Horizontal.Complexity.Classes")) %>% 
  #reorder
  select(plot, value, N_topheight_cats, shannon_topheight_cats, everything() ) %>% 
  mutate(plot = factor(plot))
```

The mean horizontal complexity value across the zone is `r round(mean(horizontal_complexity_summary$value, na.rm = TRUE), 2)`.
Horizontal complexity value is a function of the number of different top height categories present in each plot, and the Shannon diversity index of those categories.
```{r horizontal_complexity_table, results='asis'}
datatable(
  horizontal_complexity_summary %>% 
    mutate(
      value = round(value, 2),
      N_topheight_cats = as.character(N_topheight_cats),
      shannon_topheight_cats = round(shannon_topheight_cats, 2)
    ) %>%
    rename(
      Plot = plot,
      Value = value,
      'Number of top height categories' = N_topheight_cats,
      'Shannon index' = shannon_topheight_cats
    ),
  rownames = FALSE,
  caption = "Horizontal Complexity Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r horizontal_complexity_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = horizontal_complexity_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = horizontal_complexity_summary,
    aes(
      x = N_topheight_cats,
      y = value,
      colour = plot
    ),
    alpha = 0.8, 
    size = 2,
    position = position_jitter(width = 0.1, height = 3)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Number of top height categories",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Veteran trees

```{r veteran_trees_scoring}
this.sheet <- "Veteran trees"
x.axis_title <- "Veteran trees per ha"
veteran_trees_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$avts
  
  tibble(
    plot = i,
    N_avt_n = ind$ind.avt_number,
    dens_avt = ind$ind.avt_density
  ) %>% 
    #reorder
    select(plot, N_avt_n, dens_avt) %>%
    mutate(plot = factor(plot))
})

# estimate mean avt density AND 95% CI across plots
avt_dens_mean <- mean(veteran_trees_summary$dens_avt, na.rm = TRUE)
# Standard error of the mean
avt_dens_se <- sd(veteran_trees_summary$dens_avt) / sqrt(length(veteran_trees_summary$dens_avt))

# 95% confidence interval
avt_dens_ci_lower <- avt_dens_mean - qt(0.975, df = length(veteran_trees_summary$dens_avt) - 1) * avt_dens_se
avt_dens_ci_upper <- avt_dens_mean + qt(0.975, df = length(veteran_trees_summary$dens_avt) - 1) * avt_dens_se

# corresponding value (nearest)
avt_value <- veteran_trees_lookup$value[
  which.min(abs(veteran_trees_lookup$N.Veteran.Trees.per.ha - avt_dens_mean))
] 
avt_value_95ci <- veteran_trees_lookup$value[
  c(which.min(abs(veteran_trees_lookup$N.Veteran.Trees.per.ha - avt_dens_ci_lower)) ,
  which.min(abs(veteran_trees_lookup$N.Veteran.Trees.per.ha - avt_dens_ci_upper)))
] 
```
The veteran trees value across the zone is `r round(avt_value, 2)` (`r round(avt_value_95ci[1], 2)` - `r round(avt_value_95ci[2], 2)` 95% CI), based on an estimated mean AVT density of `r round(avt_dens_mean, 2)` (`r round(avt_dens_ci_lower, 2)` - `r round(avt_dens_ci_upper, 2)` 95% CI) per ha.

Note: value for the AVT indicator is calculated based on the mean AVT density across all plots, rather than the mean value across plots, as AVT condition opperates at too large a scale to be captured by individual plots.

```{r veteran_trees_table, results='asis'}
datatable(
  veteran_trees_summary %>% 
    mutate(
      N_avt_n = as.character(N_avt_n),
      dens_avt = round(dens_avt, 2)
    ) %>%
    rename(
      Plot = plot,
      'Number of AVTs' = N_avt_n,
      'AVT density (per ha)' = dens_avt
    ),
  rownames = FALSE,
  caption = "Veteran Trees Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```

```{r veteran_trees_plot, warning=FALSE, message=FALSE, fig.cap= "Estimated value for AVTs with 95% confidence interval, based on estiamte of mean avt density across the survey area. The line represents the value function for AVT density. x axis rug marks show the avt density recorded at each plot (truncated to the x axis maximum)."}

#trncate plot density to max on figure and add a jitter
plotting.denses = data.frame(plot = veteran_trees_summary$plot,
                             dens.ests = veteran_trees_summary$dens_avt %>% 
                               jitter(0.1))
plotting.denses$dens.ests[plotting.denses$dens.ests > max(veteran_trees_predictions$measure)] <- max(veteran_trees_predictions$measure)


ggplot() +
  geom_line(
    data = veteran_trees_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1
  ) +
  geom_point(
    aes(
      x = avt_dens_mean,
      y = avt_value
    ),
    # alpha = 0.8, 
    size = 4, fill = "steelblue", shape = 21, colour = "black"
  ) +
  # Add 95% CI as error bars
  geom_errorbar(
    aes(
      x = avt_dens_mean,
      ymin = avt_value_95ci[1],
      ymax = avt_value_95ci[2]
    ),
    width = 0.1, colour = "steelblue", size = 0.5
  ) +
  # x axis rug marks for density in each plot, truncated to max from veteran_trees_predictions
  geom_rug(
    data = plotting.denses,
    aes(x = dens.ests, colour = as.factor(plot)),
    sides = "b",
    alpha = 0.9, size = 0.5
  ) +
    scale_color_manual(values= wt_palette[-c(1,2,4)]) +
# Axes and titles
  labs(
    x = "AVTs per ha",
    y = "Value",
    title = paste(this.sheet, "estimated value function")
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Dead and decaying wood
```{r dead_decaying_wood_scoring}
this.sheet <- "Dead and decaying wood"
x.axis_title <- "Mean deadwood-types (of four types) per plot quarter"
dead_decaying_wood_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$deadwood
  
  # Base row: plot number and number of type-quarters
  base <- tibble(
    plot = i,
    N_type_quaters = ind$ind.deadwood_type_quaters
  )

  # Count presence per deadwood type across quarters
  type_counts <- ind$deadwood_df %>%
    rowwise() %>%
    mutate(n_quarters = sum(c_across(starts_with("Q")), na.rm = TRUE)) %>%
    ungroup() %>%
    select(deadwood_type, n_quarters) %>%
    pivot_wider(
      names_from = deadwood_type,
      values_from = n_quarters,
      values_fill = 0
    )

  # Combine base and type counts
  bind_cols(base, type_counts) %>%
    mutate(plot = factor(plot))
}) %>%
  # Join the value score using the volume-based lookup
  left_join(deadwood_lookup, by = c("N_type_quaters" = "N.Deadwood.Categories")) %>%
  # add average Ntype per quarter
  mutate(average_N_type_quaters = N_type_quaters / 4) %>%
  # Reorder for clarity
  select(plot, value, average_N_type_quaters, N_type_quaters, everything()) %>%
  mutate(plot = factor(plot))
```
The mean dead and decaying wood value across the zone is `r round(mean(dead_decaying_wood_summary$value, na.rm = TRUE), 2)`.

```{r dead_decaying_wood_table, results='asis'}
datatable(
  dead_decaying_wood_summary %>% 
    mutate(
      value = round(value, 2),
      average_N_type_quaters = round(average_N_type_quaters, 2),
      N_type_quaters = as.character(N_type_quaters)
    ) %>%
    rename(
      Plot = plot,
      Value = value,
      'Average deadwood types per quarter' = average_N_type_quaters,
      'N type-quarters' = N_type_quaters
    ),
  rownames = FALSE,
  caption = "Dead and Decaying Wood Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r dead_decaying_wood_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = deadwood_predictions,
    aes(x = measure/4, y = value),
    color = "black", size = 1, alpha = 0.8
  ) +
  geom_point(
    data = dead_decaying_wood_summary,
    aes(
      x = average_N_type_quaters,
      y = value,
      fill = plot
    ),
    alpha = 0.95, 
    size = 3,
    position = position_jitter(width = 0.05, height = 0),
    shape = 21, colour = "black"
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Average deadwood types per quarter",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Herbivore impact
```{r herbivore_impact_scoring}
this.sheet <- "Herbivore impact"
x.axis_title <- "Herbivore impact score"


herbivore_impact_lookup_clean <- Herbivore_impact_lookup %>%
  mutate(
    herbivore_impact_class = case_when(
      str_detect(Damage.class..potential.12.month.growth.removed, "^Negligable") ~ "Negligable damage",
      str_detect(Damage.class..potential.12.month.growth.removed, "^Low damage") ~ "Low damage",
      str_detect(Damage.class..potential.12.month.growth.removed, "^Moderate") ~ "Moderate damage",
      str_detect(Damage.class..potential.12.month.growth.removed, "^High damage") ~ "High damage",
      str_detect(Damage.class..potential.12.month.growth.removed, "^Very high") ~ "Very high damage",
      TRUE ~ NA_character_
    )
  ) %>%
  select(herbivore_impact_class, value) %>% 
  mutate(herbivore_impact_class = factor(herbivore_impact_class, 
                                         levels = c("Negligable damage", "Low damage", "Moderate damage", "High damage", "Very high damage")))

herbivore_impact_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$herbivore_impact
  tibble(
    plot = i,
    herbivore_impact_class = ind$ind.herbivore_impact.class,
    palatable_removed = ind$herbivore_impact_df$per_removed[ind$herbivore_impact_df$palatability == "Palatatble species"],
    unpalatable_removed = ind$herbivore_impact_df$per_removed[ind$herbivore_impact_df$palatability == "Un-palatatble species"],
  ) %>%
  left_join(herbivore_impact_lookup_clean, by = "herbivore_impact_class") %>%
  select(plot, value, herbivore_impact_class, palatable_removed, unpalatable_removed) %>%
  mutate(plot = factor(plot),
         herbivore_impact_class = factor(herbivore_impact_class, 
                                         levels = c("Negligable damage", "Low damage", "Moderate damage", "High damage", "Very high damage"))
  ) 
}) 

```
The mean herbivore impact value across the zone is `r round(mean(herbivore_impact_summary$value, na.rm = TRUE), 2)`.
Herbivore impact value is a function of the herbivore impact class assigned to each plot, which is based on the proportion of potential growth (over previous 12-months) removed by herbivores for palatable and unpalatable tree, shrub and indicator species.

```{r herbivore_impact_table, results='asis'}
datatable(
  herbivore_impact_summary %>% 
    mutate(
      value = round(value, 2),
      palatable_removed = palatable_removed,
      unpalatable_removed = unpalatable_removed) %>%
    rename(
      Plot = plot,
      Value = value,
      'Herbivore impact class' = herbivore_impact_class,
      'Palatable removed (%)' = palatable_removed,
      'Un-palatable removed (%)' = unpalatable_removed
    ),
  rownames = FALSE,
  caption = "Herbivore Impact Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```

```{r herbivore_impact_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_errorbar(
    data = herbivore_impact_lookup_clean,
    aes(
      x = herbivore_impact_class,
      ymin = value,
      ymax = value
    ),
    width = 0.6,          # controls horizontal length of line
    color = "black",
    size = 1,
    alpha = vf_alpha
  ) +
  geom_point(
    data = herbivore_impact_summary,
    aes(
      x = herbivore_impact_class,
      y = value,
      fill = plot
    ),
    alpha = 0.8,
    size = 3,
    position = position_jitter(width = 0.2, height = 1),
    shape = 21, colour = "black"
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Herbivore impact class",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)
)
```

## Tree health

```{r tree_health_scoring}
this.sheet <- "Tree health"
x.axis_title <- "Tree health score"
tree_health_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$tree_health
  
  tibble(
    plot = i,
    dieback_per = ind$ind.tree_health.dieback.measure*100,
    suddenmortality_per = ind$ind.tree_health.mortality.measure*100,
    worst_indicator = ind$ind.tree_health.max.dieback_mortality*100
  ) %>%
    fuzzyjoin::difference_left_join(
      tree_health_lookup,
      by = c("worst_indicator" = "Dieback.or.sudden.mortality...."),
      max_dist = Inf,
      distance_col = "dist"
    ) %>%
  select(plot, value, dieback_per, suddenmortality_per, worst_indicator, dist) %>%
  mutate(plot = factor(plot))
})%>%
  group_by(plot) %>%
  slice_min(order_by = dist, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(-dist) 
```

The mean tree health value across the zone is `r round(mean(tree_health_summary$value, na.rm = TRUE), 2)`.

Tree health value is a function of the worst of: a) canopy dieback percentage or b) tree sudden mortality percentage basal area, in each plot.

```{r tree_health_table, results='asis'}
datatable(
  tree_health_summary %>% 
    select(-worst_indicator) %>%  # remove worst indicator - supurfluous
    mutate(
      value = round(value, 2),
      dieback_per = round(dieback_per, 2),
      suddenmortality_per = round(suddenmortality_per, 2),
    ) %>%
    rename(
      Plot = plot,
      Value = value,
      'Canopy dieback (%)' = dieback_per,
      'Sudden mortality (%)' = suddenmortality_per,
    ),
  rownames = FALSE,
  caption = "Tree Health Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```
```{r tree_health_plot, warning=FALSE, message=FALSE}
ggplot() +
  geom_line(
    data = tree_health_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1.2
  ) +
  geom_point(
    data = tree_health_summary,
    aes(
      x = worst_indicator,
      y = value,
      fill = plot
    ),
    alpha = 0.8, 
    size = 3,
    position = position_jitter(width = 0.2, height = 1),
    shape = 21, colour = "black"
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Tree health score",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")
```

## Anthropogenic damage

```{r anthropogenic_damage_scoring}
this.sheet <- "Anthropogenic damage"
x.axis_title <- "Anthropogenic damage score"
anthropogenic_damage_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$anthropogenic_damage
  
  tibble(
    plot = i,
    damage_cover = as.character(ind$ind.anthropogenic_damage.measure)
) %>%
    left_join(antropogenic_damage_lookup, by = c("damage_cover" = "domin")) %>%
  select(plot, value, damage_cover) %>%
  mutate(plot = factor(plot))
}) 

```

The mean anthropogenic damage value across the zone is `r round(mean(anthropogenic_damage_summary$value, na.rm = TRUE), 2)`.

Anthropogenic damage value is a function of the cover of anthropogenic damage in each plot.

```{r anthropogenic_damage_table, results='asis'}
datatable(
  anthropogenic_damage_summary %>% 
    mutate(
      value = round(value, 2),
      damage_cover = paste(damage_cover, "%", sep = "")
    ) %>%
    rename(
      Plot = plot,
      Value = value,
      'Damage cover (%)' = damage_cover
    ),
  rownames = FALSE,
  caption = "Anthropogenic Damage Summary by Plot",
  options = list(
    pageLength = 10,
    dom = 't',
    ordering = FALSE
  )
)
```

```{r anthropogenic_damage_plot, warning=FALSE, message=FALSE}
anthro_plots_forplot <- anthropogenic_damage_summary %>%
      left_join(domin_transformer, by = c("damage_cover" = "domin"))%>%
  mutate(value_jit = value + runif(n(), -3, 3))  # manually jitter 'value' 

# for testing
# anthro_plots_forplot$max = 20

antro_damage_domin_ranges <- anthro_plots_forplot[anthro_plots_forplot$max > anthro_plots_forplot$min, ] 

ggplot() +
  # value function
  geom_line(
    data = anthropogenic_damage_predictions,
    aes(x = measure, y = value),
    color = "black", size = 1
  ) +
  # segment for domin class cover range
  geom_segment( data = antro_damage_domin_ranges,
  aes(x = min, xend = max + 0.1, y = value_jit, yend = value_jit, colour = factor(plot)),
    size = 0.5, alpha = 0.7
  ) +
  # points for each plot at domin class mid point
  geom_point(
    data = anthro_plots_forplot ,
    aes(
      x = mid,
      y = value_jit,
      fill = plot
    ),
    alpha = 0.8, 
    size = 3,
    shape = 21, colour = "black",
    position = position_jitter(width = 2, height = 0)
  ) +
  scale_color_manual(values= wt_palette[-c(1,2,4)]) +
  # Axes and titles
  labs(
    x = "Anthropogenic damage cover (%)",
    y = "Value",
    title = paste(this.sheet, "estimated value function"),
    fill = "Plot type"
  ) +
  # Theme and tweaks
  theme_pubr() +
  theme(legend.position = "none")

```



## Ground flora

```{r ground_flora_scoring}
this.sheet <- "Ground flora"
x.axis_title <- "Ground flora cover (%)"
ground_flora_summary <- map_dfr(seq_along(survey_data), function(i) {
  ind <- survey_data[[i]]$indicators$ground_flora
  
  tibble(
    plot = i,
    ground_flora_cover = ind$ind.ground_flora_cover,
    ground_flora_n = ind$ind.ground_flora_n
  ) %>%
  fuzzyjoin::difference_left_join(
    ground_flora_lookup,
    by = c("ground_flora_cover" = "Ground.flora.cover.."),
    max_dist = Inf,
    distance_col = "dist"
  ) %>%
  group_by(plot) %>%
  slice_min(order_by = dist, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(-dist) %>%
  select(plot, value, ground_flora_cover, ground_flora_n) %>%
  mutate(plot = factor(plot))
})
```
The mean ground flora value across the zone is `r round(mean(ground_flora_summary$value, na.rm = TRUE), 2)`.

